<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuickPost</title>
    <style>
      :root {
        --bg-primary: #1a1a1a;
        --bg-secondary: #242424;
        --text-primary: #e0e0e0;
        --text-secondary: #a0a0a0;
        --border: #333;
        --accent: #4a9eff;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
        background: var(--bg-primary);
        color: var(--text-primary);
        height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .header {
        display: flex;
        align-items: center;
        padding: 10px 20px;
        background: var(--bg-secondary);
        border-bottom: 1px solid var(--border);
        gap: 16px;
      }

      .header h1 {
        font-size: 18px;
        font-weight: 500;
        margin: 0;
        flex-shrink: 0;
      }

      .title-field-header {
        flex: 1;
        max-width: 400px;
      }

      .title-input-header {
        width: 100%;
        background: transparent;
        color: var(--text-primary);
        border: none;
        padding: 0;
        font-size: 18px;
        font-weight: 500;
        outline: none;
        transition: color 0.2s;
        min-height: 22px;
      }

      .title-input-header:focus {
        color: var(--accent);
      }

      .title-input-header::placeholder {
        color: var(--text-secondary);
        font-weight: 300;
        font-style: italic;
      }

      .title-input-header:empty:before,
      .title-input-header:placeholder-shown {
        font-style: italic;
      }

      .header button {
        background: var(--accent);
        color: white;
        border: none;
        padding: 6px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        margin-left: 8px;
      }

      .header button:hover {
        opacity: 0.9;
      }

      .posts-selector {
        margin: 0 10px;
      }

      .posts-selector select {
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        color: var(--text-primary);
        padding: 8px 12px;
        border-radius: 4px;
        font-family: inherit;
        font-size: 14px;
        min-width: 200px;
      }

      .posts-selector select:focus {
        outline: none;
        border-color: var(--accent);
      }

      .container {
        display: flex;
        flex: 1;
        overflow: hidden;
      }

      .editor-pane, .preview-pane {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .editor-pane {
        border-right: 1px solid var(--border);
      }

      .pane-header {
        padding: 10px 20px;
        background: var(--bg-secondary);
        font-size: 12px;
        text-transform: uppercase;
        color: var(--text-secondary);
        letter-spacing: 1px;
      }

      .editor-split {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .frontmatter-section {
        min-height: 120px;
        max-height: 200px;
        display: flex;
        flex-direction: column;
        border-bottom: 1px solid var(--border);
      }

      .content-section {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 200px;
      }

      .section-header {
        padding: 8px 20px;
        background: var(--bg-secondary);
        font-size: 11px;
        text-transform: uppercase;
        color: var(--text-secondary);
        letter-spacing: 1px;
        border-bottom: 1px solid var(--border);
      }

      .editor-divider {
        height: 1px;
        background: var(--border);
        margin: 0;
      }

      #frontmatter-editor, #content-editor {
        flex: 1;
        background: var(--bg-primary);
        color: var(--text-primary);
        border: none;
        padding: 20px;
        font-family: "SF Mono", Monaco, "Cascadia Code", monospace;
        font-size: 14px;
        line-height: 1.6;
        resize: none;
        outline: none;
        min-height: 80px;
      }

      #frontmatter-editor {
        background: rgba(74, 158, 255, 0.03);
        font-size: 13px;
      }

      #frontmatter-editor::placeholder {
        color: var(--text-secondary);
        opacity: 0.7;
      }

      #content-editor::placeholder {
        color: var(--text-secondary);
        opacity: 0.5;
      }

      #preview {
        flex: 1;
        padding: 20px;
        overflow-y: auto;
        font-size: 16px;
        line-height: 1.6;
      }

      /* Markdown styles */
      #preview h1 {
        margin-bottom: 16px;
        font-size: 32px;
        border-bottom: 2px solid var(--border);
        padding-bottom: 8px;
      }
      #preview h2 {
        margin: 24px 0 16px;
        font-size: 24px;
        border-bottom: 1px solid var(--border);
        padding-bottom: 4px;
      }
      #preview h3 {
        margin: 20px 0 12px;
        font-size: 20px;
      }
      #preview h4 {
        margin: 16px 0 8px;
        font-size: 18px;
      }
      #preview h5 {
        margin: 12px 0 8px;
        font-size: 16px;
      }
      #preview h6 {
        margin: 12px 0 8px;
        font-size: 14px;
        color: var(--text-secondary);
      }
      #preview p {
        margin-bottom: 16px;
      }
      #preview ul, #preview ol {
        margin-bottom: 16px;
        padding-left: 24px;
      }
      #preview li {
        margin-bottom: 4px;
      }
      #preview pre {
        background: var(--bg-secondary);
        padding: 16px;
        border-radius: 4px;
        overflow-x: auto;
        margin-bottom: 16px;
      }
      #preview code {
        background: var(--bg-secondary);
        padding: 2px 4px;
        border-radius: 2px;
        font-family: "SF Mono", Monaco, monospace;
        font-size: 14px;
      }
      #preview pre code {
        background: none;
        padding: 0;
      }
      #preview blockquote {
        border-left: 4px solid var(--accent);
        padding-left: 16px;
        margin: 16px 0;
        color: var(--text-secondary);
      }
      #preview a {
        color: var(--accent);
        text-decoration: none;
      }
      #preview a:hover {
        text-decoration: underline;
      }
      #preview img {
        max-width: 100%;
        height: auto;
        display: block;
        margin: 16px 0;
      }
      #preview table {
        border-collapse: collapse;
        width: 100%;
        margin-bottom: 16px;
      }
      #preview th, #preview td {
        border: 1px solid var(--border);
        padding: 8px 12px;
        text-align: left;
      }
      #preview th {
        background: var(--bg-secondary);
        font-weight: 600;
      }
      #preview tr:nth-child(even) {
        background: rgba(255, 255, 255, 0.02);
      }
      /* Task lists */
      #preview input[type="checkbox"] {
        margin-right: 6px;
      }
      #preview .task-list-item {
        list-style: none;
        margin-left: -20px;
      }

      .status-bar {
        display: flex;
        padding: 8px 20px;
        background: var(--bg-secondary);
        border-top: 1px solid var(--border);
        font-size: 12px;
        color: var(--text-secondary);
      }

      .status-bar span {
        margin-right: 20px;
      }

      @media (max-width: 768px) {
        .container {
          flex-direction: column;
        }
        .editor-pane {
          border-right: none;
          border-bottom: 1px solid var(--border);
        }
        .frontmatter-section {
          min-height: 100px;
          max-height: 150px;
        }
        .content-section {
          min-height: 150px;
        }
      }

      /* Override Prism theme to remove brown border and improve styling */
      pre[class*="language-"] {
        border: none !important;
        border-radius: 6px;
        background: var(--bg-secondary) !important;
      }

      code[class*="language-"] {
        background: transparent !important;
      }
    </style>
    <link rel="stylesheet" href="/prism-dark.css">
    <script src="/marked.min.js"></script>
    <script src="/prism.min.js"></script>
    <script src="/prism-json.min.js"></script>
    <script src="/prism-bash.min.js"></script>
    <script src="/prism-typescript.min.js"></script>
    <script src="/prism-python.min.js"></script>
    <script src="/prism-sql.min.js"></script>
    <script src="/prism-markdown.min.js"></script>
    <script src="/prism-lua.min.js"></script>
    <script src="/prism-go.min.js"></script>
    <script src="/prism-rust.min.js"></script>
    <script src="/prism-java.min.js"></script>
    <script src="/prism-docker.min.js"></script>
    <script src="/prism-yaml.min.js"></script>
  </head>
  <body>
    <div class="header">
      <h1>QuickPost</h1>
      <div class="title-field-header">
        <input
          type="text"
          id="titleInput"
          placeholder="Post title (auto-extracted from content)"
          class="title-input-header"
        />
      </div>
      <div class="posts-selector">
        <select id="postsDropdown">
          <option value="">Select existing post...</option>
        </select>
      </div>
      <button id="newBtn">New Post</button>
      <button id="saveBtn">Save</button>
      <button id="exportBtn">Export</button>
    </div>

    <div class="container">
      <div class="editor-pane">
        <div class="pane-header">Markdown</div>
        <div class="editor-split">
          <div class="frontmatter-section">
            <div class="section-header">Frontmatter</div>
            <textarea
              id="frontmatter-editor"
              placeholder="title: Post Title
publishDate: 2025-01-01T00:00:00-07:00
draft: true"
            ></textarea>
          </div>
          <div class="editor-divider"></div>
          <div class="content-section">
            <div class="section-header">Content</div>
            <textarea
              id="content-editor"
              placeholder="Start writing in markdown...

# Heading 1
## Heading 2

**Bold text** and *italic text*

- Bullet point
- [ ] Task item
- [x] Completed task

`inline code` and code blocks:

```javascript
console.log('Hello, World!');
```

[Link text](https://example.com)
![Alt text](image.png)

> Blockquote

| Column 1 | Column 2 |
|----------|----------|
| Cell 1   | Cell 2   |"
            ></textarea>
          </div>
        </div>
      </div>
      <div class="preview-pane">
        <div class="pane-header">Preview</div>
        <div id="preview"></div>
      </div>
    </div>

    <div class="status-bar">
      <span id="wordCount">0 words</span>
      <span id="charCount">0 characters</span>
      <span id="status">Ready</span>
    </div>

    <script>
      // Configure marked for GitHub Flavored Markdown
      marked.use({
        gfm: true,
        breaks: true,
      });

      // Simple HTML sanitizer (basic XSS protection)
      function sanitizeHtml(html) {
        const temp = document.createElement("div");
        temp.innerHTML = html;

        // Remove script tags and event handlers
        const scripts = temp.querySelectorAll("script");
        scripts.forEach((s) => s.remove());

        const allElements = temp.querySelectorAll("*");
        allElements.forEach((el) => {
          // Remove all event handlers
          for (let attr of el.attributes) {
            if (attr.name.startsWith("on")) {
              el.removeAttribute(attr.name);
            }
          }
        });

        return temp.innerHTML;
      }

      // Get combined content from both editors
      function getCombinedContent() {
        const frontmatterEditor = document.getElementById("frontmatter-editor");
        const contentEditor = document.getElementById("content-editor");

        const frontmatter = frontmatterEditor.value.trim();
        const content = contentEditor.value;

        if (!frontmatter) {
          return content;
        }

        return `---\n${frontmatter}\n---\n${content}`;
      }

      // Split content into frontmatter and body
      function splitContent(fullContent) {
        const { frontmatter, body } = parseFrontmatter(fullContent);

        // Convert frontmatter object back to YAML string
        let frontmatterText = "";
        if (Object.keys(frontmatter).length > 0) {
          frontmatterText = Object.entries(frontmatter)
            .map(([key, value]) => `${key}: ${value}`)
            .join("\n");
        }

        return { frontmatterText, bodyText: body };
      }

      // Update editors with content
      function updateEditors(fullContent) {
        const frontmatterEditor = document.getElementById("frontmatter-editor");
        const contentEditor = document.getElementById("content-editor");

        const { frontmatterText, bodyText } = splitContent(fullContent);

        frontmatterEditor.value = frontmatterText;
        contentEditor.value = bodyText;
      }

      // Update preview
      function updatePreview() {
        const preview = document.getElementById("preview");
        const fullContent = getCombinedContent();

        try {
          // Parse frontmatter and only render the body content in preview
          const { frontmatter, body } = parseFrontmatter(fullContent);
          const html = marked.parse(body);
          preview.innerHTML = sanitizeHtml(html);

          // Handle task list checkboxes
          preview.querySelectorAll('input[type="checkbox"]').forEach((cb) => {
            cb.disabled = false;
            cb.addEventListener("change", (e) => {
              e.preventDefault();
              // In a real app, this would update the markdown source
              console.log("Task toggled");
            });
          });

          // Apply syntax highlighting to code blocks
          if (typeof Prism !== "undefined") {
            // Use requestAnimationFrame for smooth performance
            requestAnimationFrame(() => {
              Prism.highlightAllUnder(preview);
            });
          }
        } catch (error) {
          console.error("Markdown parsing error:", error);
          preview.innerHTML = '<p style="color: red;">Error parsing markdown</p>';
        }

        updateStatus();
        updateTitleField();
      }

      // Update status bar
      function updateStatus() {
        const text = getCombinedContent();
        const words = text.trim().split(/\s+/).filter((w) => w.length > 0).length;
        const chars = text.length;

        document.getElementById("wordCount").textContent = `${words} words`;
        document.getElementById("charCount").textContent = `${chars} characters`;
      }

      // Extract title from content (frontmatter or first heading)
      function extractTitle(content) {
        const { frontmatter, body } = parseFrontmatter(content);

        // Use frontmatter title if available
        if (frontmatter.title) {
          return frontmatter.title;
        }

        // Extract from first heading in content
        const lines = content.split("\n");
        for (const line of lines) {
          const trimmed = line.trim();
          if (trimmed.startsWith("#")) {
            return trimmed.replace(/^#+\s*/, "");
          }
        }

        return "";
      }

      // Update title field based on content
      function updateTitleField() {
        const content = getCombinedContent();
        const titleInput = document.getElementById("titleInput");
        const extractedTitle = extractTitle(content);

        // Only update if not manually edited and (field is empty or matches the previously extracted title)
        if (
          !titleInput.dataset.manuallyEdited &&
          (!titleInput.value || titleInput.dataset.autoExtracted === titleInput.value)
        ) {
          titleInput.value = extractedTitle;
          titleInput.dataset.autoExtracted = extractedTitle;
        }
      }

      // Simple frontmatter parser for frontend
      function parseFrontmatter(content) {
        const frontmatterRegex = /^---\n([\s\S]*?)\n---\n([\s\S]*)$/;
        const match = content.match(frontmatterRegex);

        if (!match) {
          return { frontmatter: {}, body: content };
        }

        try {
          const frontmatterText = match[1];
          const frontmatter = {};

          // Simple YAML-like parsing for basic key: value pairs
          frontmatterText.split("\n").forEach((line) => {
            const colonIndex = line.indexOf(":");
            if (colonIndex > 0) {
              const key = line.slice(0, colonIndex).trim();
              const value = line.slice(colonIndex + 1).trim().replace(/^["']|["']$/g, "");
              frontmatter[key] = value;
            }
          });

          return { frontmatter, body: match[2] };
        } catch {
          return { frontmatter: {}, body: content };
        }
      }

      // Save post
      async function savePost() {
        const content = getCombinedContent();
        const titleInput = document.getElementById("titleInput");

        // Use title from title field if available, otherwise extract from content
        let title = titleInput.value.trim();
        if (!title) {
          title = extractTitle(content) || "Untitled";
        }

        try {
          let response;

          if (window.currentPostId) {
            // Update existing post
            response = await fetch(`/api/posts/${window.currentPostId}`, {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title, content }),
            });
          } else {
            // Create new post
            response = await fetch("/api/posts", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title, content }),
            });
          }

          if (response.ok) {
            const post = await response.json();
            document.getElementById("status").textContent = "Saved";
            window.currentPostId = post.id;
            setTimeout(() => {
              document.getElementById("status").textContent = "Ready";
            }, 2000);
          }
        } catch (error) {
          console.error("Failed to save:", error);
          document.getElementById("status").textContent = "Error saving";
        }
      }

      // Export post
      async function exportPost() {
        const content = getCombinedContent();
        const blob = new Blob([content], { type: "text/markdown" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "post.md";
        a.click();
        URL.revokeObjectURL(url);
      }

      // Load posts into dropdown
      async function loadPostsList() {
        try {
          const response = await fetch("/api/posts");
          if (response.ok) {
            const posts = await response.json();
            const dropdown = document.getElementById("postsDropdown");

            // Clear existing options except the first one
            dropdown.innerHTML = '<option value="">Select existing post...</option>';

            // Add posts as options
            posts.forEach((post) => {
              const option = document.createElement("option");
              option.value = post.id;
              option.textContent = post.title || "Untitled";
              dropdown.appendChild(option);
            });
          }
        } catch (error) {
          console.error("Failed to load posts:", error);
        }
      }

      // Load selected post into editor
      async function loadPost(postId) {
        if (!postId) {
          // Clear editors if no post selected
          clearEditors();
          return;
        }

        try {
          const response = await fetch(`/api/posts/${postId}`);
          if (response.ok) {
            const post = await response.json();

            // Set current post ID
            window.currentPostId = post.id;

            // Update title field
            document.getElementById("titleInput").value = post.title || "";

            // Load content into editors
            updateEditors(post.content || "");

            // Update preview
            updatePreview();

            document.getElementById("status").textContent = "Post loaded";
            setTimeout(() => {
              document.getElementById("status").textContent = "Ready";
            }, 2000);
          }
        } catch (error) {
          console.error("Failed to load post:", error);
          document.getElementById("status").textContent = "Error loading post";
        }
      }

      // Clear editors for new post
      function clearEditors() {
        document.getElementById("frontmatter-editor").value = "";
        document.getElementById("content-editor").value = "";
        document.getElementById("titleInput").value = "";
        document.getElementById("postsDropdown").value = "";
        window.currentPostId = null;
        updatePreview();
      }

      // Initialize
      document.addEventListener("DOMContentLoaded", () => {
        const frontmatterEditor = document.getElementById("frontmatter-editor");
        const contentEditor = document.getElementById("content-editor");

        // Update preview on input with debouncing for both editors
        let debounceTimer;
        function handleEditorInput() {
          clearTimeout(debounceTimer);
          debounceTimer = setTimeout(updatePreview, 100);
        }

        frontmatterEditor.addEventListener("input", handleEditorInput);
        contentEditor.addEventListener("input", handleEditorInput);

        // Save shortcut (Cmd/Ctrl + S) for both editors
        function handleKeydown(e) {
          if ((e.metaKey || e.ctrlKey) && e.key === "s") {
            e.preventDefault();
            savePost();
          }
        }

        frontmatterEditor.addEventListener("keydown", handleKeydown);
        contentEditor.addEventListener("keydown", handleKeydown);

        // Button handlers
        document.getElementById("saveBtn").addEventListener("click", savePost);
        document.getElementById("exportBtn").addEventListener("click", exportPost);
        document.getElementById("newBtn").addEventListener("click", () => {
          if (confirm("Create a new post? Unsaved changes will be lost.")) {
            clearEditors();
          }
        });

        // Posts dropdown handler
        document.getElementById("postsDropdown").addEventListener("change", (e) => {
          loadPost(e.target.value);
        });

        // Title field event listeners
        const titleInput = document.getElementById("titleInput");
        titleInput.addEventListener("input", () => {
          // Mark as manually edited to prevent auto-updates
          titleInput.dataset.manuallyEdited = "true";
        });

        // Initial update
        updatePreview();

        // Auto-save draft to localStorage
        setInterval(() => {
          localStorage.setItem("quickpost-draft", getCombinedContent());
        }, 5000);

        // Restore draft
        const draft = localStorage.getItem("quickpost-draft");
        if (draft) {
          updateEditors(draft);
          updatePreview();
        }

        // Focus content editor by default
        contentEditor.focus();

        // Initialize the page
        loadPostsList();
      });
    </script>
  </body>
</html>

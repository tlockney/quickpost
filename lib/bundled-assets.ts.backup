// This file is auto-generated by scripts/bundle-assets.ts
// DO NOT EDIT MANUALLY

export interface AssetInfo {
  content: string;
  isBinary: boolean;
}

export const assets: Record<string, AssetInfo> = {
  "prism-python.min.js": {
    content: `Prism.languages.python = {
  comment: { pattern: /(^|[^\\\\])#.*/, lookbehind: !0, greedy: !0 },
  "string-interpolation": {
    pattern: /(?:f|fr|rf)(?:("""|''')[\\s\\S]*?\\1|("|')(?:\\\\.|(?!\\2)[^\\\\\\r\\n])*\\2)/i,
    greedy: !0,
    inside: {
      interpolation: {
        pattern:
          /((?:^|[^{])(?:\\{\\{)*)\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}])+\\})+\\})+\\}/,
        lookbehind: !0,
        inside: {
          "format-spec": { pattern: /(:)[^:(){}]+(?=\\}$)/, lookbehind: !0 },
          "conversion-option": { pattern: /![sra](?=[:}]$)/, alias: "punctuation" },
          rest: null,
        },
      },
      string: /[\\s\\S]+/,
    },
  },
  "triple-quoted-string": {
    pattern: /(?:[rub]|br|rb)?("""|''')[\\s\\S]*?\\1/i,
    greedy: !0,
    alias: "string",
  },
  string: { pattern: /(?:[rub]|br|rb)?("|')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/i, greedy: !0 },
  function: { pattern: /((?:^|\\s)def[ \\t]+)[a-zA-Z_]\\w*(?=\\s*\\()/g, lookbehind: !0 },
  "class-name": { pattern: /(\\bclass\\s+)\\w+/i, lookbehind: !0 },
  decorator: {
    pattern: /(^[\\t ]*)@\\w+(?:\\.\\w+)*/m,
    lookbehind: !0,
    alias: ["annotation", "punctuation"],
    inside: { punctuation: /\\./ },
  },
  keyword:
    /\\b(?:_(?=\\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\\b/,
  builtin:
    /\\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\\b/,
  boolean: /\\b(?:False|None|True)\\b/,
  number:
    /\\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\\b|(?:\\b\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\B\\.\\d+(?:_\\d+)*)(?:e[+-]?\\d+(?:_\\d+)*)?j?(?!\\w)/i,
  operator: /[-+%=]=?|!=|:=|\\*\\*?=?|\\/\\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  punctuation: /[{}[\\];(),.:]/,
},
  Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest =
    Prism.languages.python,
  Prism.languages.py = Prism.languages.python;
`,
    isBinary: false,
  },
  "prism-java.min.js": {
    content: `!function (e) {
  var n =
      /\\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\\s*[(){}[\\]<>=%~.:,;?+\\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\\b/,
    t = "(?:[a-z]\\\\w*\\\\s*\\\\.\\\\s*)*(?:[A-Z]\\\\w*\\\\s*\\\\.\\\\s*)*",
    s = {
      pattern: RegExp("(^|[^\\\\w.])" + t + "[A-Z](?:[\\\\d_A-Z]*[a-z]\\\\w*)?\\\\b"),
      lookbehind: !0,
      inside: {
        namespace: {
          pattern: /^[a-z]\\w*(?:\\s*\\.\\s*[a-z]\\w*)*(?:\\s*\\.)?/,
          inside: { punctuation: /\\./ },
        },
        punctuation: /\\./,
      },
    };
  e.languages.java = e.languages.extend("clike", {
    string: { pattern: /(^|[^\\\\])"(?:\\\\.|[^"\\\\\\r\\n])*"/, lookbehind: !0, greedy: !0 },
    "class-name": [s, {
      pattern: RegExp(
        "(^|[^\\\\w.])" + t +
          "[A-Z]\\\\w*(?=\\\\s+\\\\w+\\\\s*[;,=()]|\\\\s*(?:\\\\[[\\\\s,]*\\\\]\\\\s*)?::\\\\s*new\\\\b)",
      ),
      lookbehind: !0,
      inside: s.inside,
    }, {
      pattern: RegExp(
        "(\\\\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\\\\s+)" + t +
          "[A-Z]\\\\w*\\\\b",
      ),
      lookbehind: !0,
      inside: s.inside,
    }],
    keyword: n,
    function: [e.languages.clike.function, { pattern: /(::\\s*)[a-z_]\\w*/, lookbehind: !0 }],
    number:
      /\\b0b[01][01_]*L?\\b|\\b0x(?:\\.[\\da-f_p+-]+|[\\da-f_]+(?:\\.[\\da-f_p+-]+)?)\\b|(?:\\b\\d[\\d_]*(?:\\.[\\d_]*)?|\\B\\.\\d[\\d_]*)(?:e[+-]?\\d[\\d_]*)?[dfl]?/i,
    operator: {
      pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\\+\\+|&&|\\|\\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
      lookbehind: !0,
    },
    constant: /\\b[A-Z][A-Z_\\d]+\\b/,
  }),
    e.languages.insertBefore("java", "string", {
      "triple-quoted-string": {
        pattern: /"""[ \\t]*[\\r\\n](?:(?:"|"")?(?:\\\\.|[^"\\\\]))*"""/,
        greedy: !0,
        alias: "string",
      },
      char: { pattern: /'(?:\\\\.|[^'\\\\\\r\\n]){1,6}'/, greedy: !0 },
    }),
    e.languages.insertBefore("java", "class-name", {
      annotation: { pattern: /(^|[^.])@\\w+(?:\\s*\\.\\s*\\w+)*/, lookbehind: !0, alias: "punctuation" },
      generics: {
        pattern:
          /<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&))*>)*>)*>)*>/,
        inside: { "class-name": s, keyword: n, punctuation: /[<>(),.:]/, operator: /[?&|]/ },
      },
      import: [{
        pattern: RegExp("(\\\\bimport\\\\s+)" + t + "(?:[A-Z]\\\\w*|\\\\*)(?=\\\\s*;)"),
        lookbehind: !0,
        inside: {
          namespace: s.inside.namespace,
          punctuation: /\\./,
          operator: /\\*/,
          "class-name": /\\w+/,
        },
      }, {
        pattern: RegExp("(\\\\bimport\\\\s+static\\\\s+)" + t + "(?:\\\\w+|\\\\*)(?=\\\\s*;)"),
        lookbehind: !0,
        alias: "static",
        inside: {
          namespace: s.inside.namespace,
          static: /\\b\\w+$/,
          punctuation: /\\./,
          operator: /\\*/,
          "class-name": /\\w+/,
        },
      }],
      namespace: {
        pattern: RegExp(
          "(\\\\b(?:exports|import(?:\\\\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\\\\s+)(?!<keyword>)[a-z]\\\\w*(?:\\\\.[a-z]\\\\w*)*\\\\.?"
            .replace(/<keyword>/g, function () {
              return n.source;
            }),
        ),
        lookbehind: !0,
        inside: { punctuation: /\\./ },
      },
    });
}(Prism);
`,
    isBinary: false,
  },
  "prism-json.min.js": {
    content: `Prism.languages.json = {
  property: { pattern: /(^|[^\\\\])"(?:\\\\.|[^\\\\"\\r\\n])*"(?=\\s*:)/, lookbehind: !0, greedy: !0 },
  string: { pattern: /(^|[^\\\\])"(?:\\\\.|[^\\\\"\\r\\n])*"(?!\\s*:)/, lookbehind: !0, greedy: !0 },
  comment: { pattern: /\\/\\/.*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, greedy: !0 },
  number: /-?\\b\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,
  punctuation: /[{}[\\],]/,
  operator: /:/,
  boolean: /\\b(?:false|true)\\b/,
  null: { pattern: /\\bnull\\b/, alias: "keyword" },
}, Prism.languages.webmanifest = Prism.languages.json;
`,
    isBinary: false,
  },
  "index.html": {
    content: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuickPost</title>
    <style>
      :root {
        --bg-primary: #1a1a1a;
        --bg-secondary: #242424;
        --text-primary: #e0e0e0;
        --text-secondary: #a0a0a0;
        --border: #333;
        --accent: #4a9eff;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
        background: var(--bg-primary);
        color: var(--text-primary);
        height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .header {
        display: flex;
        align-items: center;
        padding: 10px 20px;
        background: var(--bg-secondary);
        border-bottom: 1px solid var(--border);
        gap: 16px;
      }

      .header h1 {
        font-size: 18px;
        font-weight: 500;
        margin: 0;
        flex-shrink: 0;
      }

      .title-field-header {
        flex: 1;
        max-width: 400px;
      }

      .title-input-header {
        width: 100%;
        background: transparent;
        color: var(--text-primary);
        border: none;
        padding: 0;
        font-size: 18px;
        font-weight: 500;
        outline: none;
        transition: color 0.2s;
        min-height: 22px;
      }

      .title-input-header:focus {
        color: var(--accent);
      }

      .title-input-header::placeholder {
        color: var(--text-secondary);
        font-weight: 300;
        font-style: italic;
      }

      .title-input-header:empty:before,
      .title-input-header:placeholder-shown {
        font-style: italic;
      }

      .header button {
        background: var(--accent);
        color: white;
        border: none;
        padding: 6px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        margin-left: 8px;
      }

      .header button:hover {
        opacity: 0.9;
      }

      .container {
        display: flex;
        flex: 1;
        overflow: hidden;
      }

      .editor-pane, .preview-pane {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .editor-pane {
        border-right: 1px solid var(--border);
      }

      .pane-header {
        padding: 10px 20px;
        background: var(--bg-secondary);
        font-size: 12px;
        text-transform: uppercase;
        color: var(--text-secondary);
        letter-spacing: 1px;
      }

      #editor {
        flex: 1;
        background: var(--bg-primary);
        color: var(--text-primary);
        border: none;
        padding: 20px;
        font-family: "SF Mono", Monaco, "Cascadia Code", monospace;
        font-size: 14px;
        line-height: 1.6;
        resize: none;
        outline: none;
      }

      #preview {
        flex: 1;
        padding: 20px;
        overflow-y: auto;
        font-size: 16px;
        line-height: 1.6;
      }

      /* Markdown styles */
      #preview h1 {
        margin-bottom: 16px;
        font-size: 32px;
        border-bottom: 2px solid var(--border);
        padding-bottom: 8px;
      }
      #preview h2 {
        margin: 24px 0 16px;
        font-size: 24px;
        border-bottom: 1px solid var(--border);
        padding-bottom: 4px;
      }
      #preview h3 {
        margin: 20px 0 12px;
        font-size: 20px;
      }
      #preview h4 {
        margin: 16px 0 8px;
        font-size: 18px;
      }
      #preview h5 {
        margin: 12px 0 8px;
        font-size: 16px;
      }
      #preview h6 {
        margin: 12px 0 8px;
        font-size: 14px;
        color: var(--text-secondary);
      }
      #preview p {
        margin-bottom: 16px;
      }
      #preview ul, #preview ol {
        margin-bottom: 16px;
        padding-left: 24px;
      }
      #preview li {
        margin-bottom: 4px;
      }
      #preview pre {
        background: var(--bg-secondary);
        padding: 16px;
        border-radius: 4px;
        overflow-x: auto;
        margin-bottom: 16px;
      }
      #preview code {
        background: var(--bg-secondary);
        padding: 2px 4px;
        border-radius: 2px;
        font-family: "SF Mono", Monaco, monospace;
        font-size: 14px;
      }
      #preview pre code {
        background: none;
        padding: 0;
      }
      #preview blockquote {
        border-left: 4px solid var(--accent);
        padding-left: 16px;
        margin: 16px 0;
        color: var(--text-secondary);
      }
      #preview a {
        color: var(--accent);
        text-decoration: none;
      }
      #preview a:hover {
        text-decoration: underline;
      }
      #preview img {
        max-width: 100%;
        height: auto;
        display: block;
        margin: 16px 0;
      }
      #preview table {
        border-collapse: collapse;
        width: 100%;
        margin-bottom: 16px;
      }
      #preview th, #preview td {
        border: 1px solid var(--border);
        padding: 8px 12px;
        text-align: left;
      }
      #preview th {
        background: var(--bg-secondary);
        font-weight: 600;
      }
      #preview tr:nth-child(even) {
        background: rgba(255, 255, 255, 0.02);
      }
      /* Task lists */
      #preview input[type="checkbox"] {
        margin-right: 6px;
      }
      #preview .task-list-item {
        list-style: none;
        margin-left: -20px;
      }

      .status-bar {
        display: flex;
        padding: 8px 20px;
        background: var(--bg-secondary);
        border-top: 1px solid var(--border);
        font-size: 12px;
        color: var(--text-secondary);
      }

      .status-bar span {
        margin-right: 20px;
      }

      @media (max-width: 768px) {
        .container {
          flex-direction: column;
        }
        .editor-pane {
          border-right: none;
          border-bottom: 1px solid var(--border);
        }
      }

      /* Override Prism theme to remove brown border and improve styling */
      pre[class*="language-"] {
        border: none !important;
        border-radius: 6px;
        background: var(--bg-secondary) !important;
      }

      code[class*="language-"] {
        background: transparent !important;
      }
    </style>
    <link rel="stylesheet" href="/prism-dark.css">
    <script src="/marked.min.js"></script>
    <script src="/prism.min.js"></script>
    <script src="/prism-json.min.js"></script>
    <script src="/prism-bash.min.js"></script>
    <script src="/prism-typescript.min.js"></script>
    <script src="/prism-python.min.js"></script>
    <script src="/prism-sql.min.js"></script>
    <script src="/prism-markdown.min.js"></script>
    <script src="/prism-lua.min.js"></script>
    <script src="/prism-go.min.js"></script>
    <script src="/prism-rust.min.js"></script>
    <script src="/prism-java.min.js"></script>
    <script src="/prism-docker.min.js"></script>
    <script src="/prism-yaml.min.js"></script>
  </head>
  <body>
    <div class="header">
      <h1>QuickPost</h1>
      <div class="title-field-header">
        <input
          type="text"
          id="titleInput"
          placeholder="Post title (auto-extracted from content)"
          class="title-input-header"
        />
      </div>
      <button id="newBtn">New Post</button>
      <button id="saveBtn">Save</button>
      <button id="exportBtn">Export</button>
    </div>

    <div class="container">
      <div class="editor-pane">
        <div class="pane-header">Markdown</div>
        <textarea
          id="editor"
          placeholder="Start writing in markdown...

# Heading 1
## Heading 2

**Bold text** and *italic text*

- Bullet point
- [ ] Task item
- [x] Completed task

\`inline code\` and code blocks:

\`\`\`javascript
console.log('Hello, World!');
\`\`\`

[Link text](https://example.com)
![Alt text](image.png)

> Blockquote

| Column 1 | Column 2 |
|----------|----------|
| Cell 1   | Cell 2   |"
        ></textarea>
      </div>
      <div class="preview-pane">
        <div class="pane-header">Preview</div>
        <div id="preview"></div>
      </div>
    </div>

    <div class="status-bar">
      <span id="wordCount">0 words</span>
      <span id="charCount">0 characters</span>
      <span id="status">Ready</span>
    </div>

    <script>
      // Configure marked for GitHub Flavored Markdown
      marked.use({
        gfm: true,
        breaks: true,
      });

      // Simple HTML sanitizer (basic XSS protection)
      function sanitizeHtml(html) {
        const temp = document.createElement("div");
        temp.innerHTML = html;

        // Remove script tags and event handlers
        const scripts = temp.querySelectorAll("script");
        scripts.forEach((s) => s.remove());

        const allElements = temp.querySelectorAll("*");
        allElements.forEach((el) => {
          // Remove all event handlers
          for (let attr of el.attributes) {
            if (attr.name.startsWith("on")) {
              el.removeAttribute(attr.name);
            }
          }
        });

        return temp.innerHTML;
      }

      // Update preview
      function updatePreview() {
        const editor = document.getElementById("editor");
        const preview = document.getElementById("preview");

        try {
          const html = marked.parse(editor.value);
          preview.innerHTML = sanitizeHtml(html);

          // Handle task list checkboxes
          preview.querySelectorAll('input[type="checkbox"]').forEach((cb) => {
            cb.disabled = false;
            cb.addEventListener("change", (e) => {
              e.preventDefault();
              // In a real app, this would update the markdown source
              console.log("Task toggled");
            });
          });

          // Apply syntax highlighting to code blocks
          if (typeof Prism !== "undefined") {
            // Use requestAnimationFrame for smooth performance
            requestAnimationFrame(() => {
              Prism.highlightAllUnder(preview);
            });
          }
        } catch (error) {
          console.error("Markdown parsing error:", error);
          preview.innerHTML = '<p style="color: red;">Error parsing markdown</p>';
        }

        updateStatus();
        updateTitleField();
      }

      // Update status bar
      function updateStatus() {
        const text = document.getElementById("editor").value;
        const words = text.trim().split(/\\s+/).filter((w) => w.length > 0).length;
        const chars = text.length;

        document.getElementById("wordCount").textContent = \`\${words} words\`;
        document.getElementById("charCount").textContent = \`\${chars} characters\`;
      }

      // Extract title from content (frontmatter or first heading)
      function extractTitle(content) {
        const { frontmatter, body } = parseFrontmatter(content);

        // Use frontmatter title if available
        if (frontmatter.title) {
          return frontmatter.title;
        }

        // Extract from first heading in content
        const lines = content.split("\\n");
        for (const line of lines) {
          const trimmed = line.trim();
          if (trimmed.startsWith("#")) {
            return trimmed.replace(/^#+\\s*/, "");
          }
        }

        return "";
      }

      // Update title field based on content
      function updateTitleField() {
        const content = document.getElementById("editor").value;
        const titleInput = document.getElementById("titleInput");
        const extractedTitle = extractTitle(content);

        // Only update if not manually edited and (field is empty or matches the previously extracted title)
        if (
          !titleInput.dataset.manuallyEdited &&
          (!titleInput.value || titleInput.dataset.autoExtracted === titleInput.value)
        ) {
          titleInput.value = extractedTitle;
          titleInput.dataset.autoExtracted = extractedTitle;
        }
      }

      // Simple frontmatter parser for frontend
      function parseFrontmatter(content) {
        const frontmatterRegex = /^---\\n([\\s\\S]*?)\\n---\\n([\\s\\S]*)$/;
        const match = content.match(frontmatterRegex);

        if (!match) {
          return { frontmatter: {}, body: content };
        }

        try {
          const frontmatterText = match[1];
          const frontmatter = {};

          // Simple YAML-like parsing for basic key: value pairs
          frontmatterText.split("\\n").forEach((line) => {
            const colonIndex = line.indexOf(":");
            if (colonIndex > 0) {
              const key = line.slice(0, colonIndex).trim();
              const value = line.slice(colonIndex + 1).trim().replace(/^["']|["']$/g, "");
              frontmatter[key] = value;
            }
          });

          return { frontmatter, body: match[2] };
        } catch {
          return { frontmatter: {}, body: content };
        }
      }

      // Save post
      async function savePost() {
        const content = document.getElementById("editor").value;
        const titleInput = document.getElementById("titleInput");

        // Use title from title field if available, otherwise extract from content
        let title = titleInput.value.trim();
        if (!title) {
          title = extractTitle(content) || "Untitled";
        }

        try {
          const response = await fetch("/api/posts", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ title, content }),
          });

          if (response.ok) {
            const post = await response.json();
            document.getElementById("status").textContent = "Saved";
            window.currentPostId = post.id;
            setTimeout(() => {
              document.getElementById("status").textContent = "Ready";
            }, 2000);
          }
        } catch (error) {
          console.error("Failed to save:", error);
          document.getElementById("status").textContent = "Error saving";
        }
      }

      // Export post
      async function exportPost() {
        const content = document.getElementById("editor").value;
        const blob = new Blob([content], { type: "text/markdown" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "post.md";
        a.click();
        URL.revokeObjectURL(url);
      }

      // Initialize
      document.addEventListener("DOMContentLoaded", () => {
        const editor = document.getElementById("editor");

        // Update preview on input with debouncing
        let debounceTimer;
        editor.addEventListener("input", () => {
          clearTimeout(debounceTimer);
          debounceTimer = setTimeout(updatePreview, 100);
        });

        // Save shortcut (Cmd/Ctrl + S)
        editor.addEventListener("keydown", (e) => {
          if ((e.metaKey || e.ctrlKey) && e.key === "s") {
            e.preventDefault();
            savePost();
          }
        });

        // Button handlers
        document.getElementById("saveBtn").addEventListener("click", savePost);
        document.getElementById("exportBtn").addEventListener("click", exportPost);
        document.getElementById("newBtn").addEventListener("click", () => {
          if (confirm("Create a new post? Unsaved changes will be lost.")) {
            editor.value = "";
            document.getElementById("titleInput").value = "";
            window.currentPostId = null;
            updatePreview();
          }
        });

        // Title field event listeners
        const titleInput = document.getElementById("titleInput");
        titleInput.addEventListener("input", () => {
          // Mark as manually edited to prevent auto-updates
          titleInput.dataset.manuallyEdited = "true";
        });

        // Initial update
        updatePreview();

        // Auto-save draft to localStorage
        setInterval(() => {
          localStorage.setItem("quickpost-draft", editor.value);
        }, 5000);

        // Restore draft
        const draft = localStorage.getItem("quickpost-draft");
        if (draft) {
          editor.value = draft;
          updatePreview();
        }

        // Focus editor
        editor.focus();
      });
    </script>
  </body>
</html>
`,
    isBinary: false,
  },
  "prism-yaml.min.js": {
    content: `!function (e) {
  var n = /[*&][^\\s[\\]{},]+/,
    r = /!(?:<[\\w\\-%#;/?:@&=+$,.!~*'()[\\]]+>|(?:[a-zA-Z\\d-]*!)?[\\w\\-%#;/?:@&=+$.~*'()]+)?/,
    t = "(?:" + r.source + "(?:[ \\t]+" + n.source + ")?|" + n.source + "(?:[ \\t]+" + r.source +
      ")?)",
    a =
      "(?:[^\\\\s\\\\x00-\\\\x08\\\\x0e-\\\\x1f!\\"#%&'*,\\\\-:>?@[\\\\]\`{|}\\\\x7f-\\\\x84\\\\x86-\\\\x9f\\\\ud800-\\\\udfff\\\\ufffe\\\\uffff]|[?:-]<PLAIN>)(?:[ \\t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*"
        .replace(/<PLAIN>/g, function () {
          return "[^\\\\s\\\\x00-\\\\x08\\\\x0e-\\\\x1f,[\\\\]{}\\\\x7f-\\\\x84\\\\x86-\\\\x9f\\\\ud800-\\\\udfff\\\\ufffe\\\\uffff]";
        }),
    d = "\\"(?:[^\\"\\\\\\\\\\r\\n]|\\\\\\\\.)*\\"|'(?:[^'\\\\\\\\\\r\\n]|\\\\\\\\.)*'";
  function o(e, n) {
    n = (n || "").replace(/m/g, "") + "m";
    var r =
      "([:\\\\-,[{]\\\\s*(?:\\\\s<<prop>>[ \\t]+)?)(?:<<value>>)(?=[ \\t]*(?:$|,|\\\\]|\\\\}|(?:[\\r\\n]\\\\s*)?#))"
        .replace(/<<prop>>/g, function () {
          return t;
        }).replace(/<<value>>/g, function () {
          return e;
        });
    return RegExp(r, n);
  }
  e.languages.yaml = {
    scalar: {
      pattern: RegExp(
        "([\\\\-:]\\\\s*(?:\\\\s<<prop>>[ \\t]+)?[|>])[ \\t]*(?:((?:\\r?\\n|\\r)[ \\t]+)\\\\S[^\\r\\n]*(?:\\\\2[^\\r\\n]+)*)"
          .replace(/<<prop>>/g, function () {
            return t;
          }),
      ),
      lookbehind: !0,
      alias: "string",
    },
    comment: /#.*/,
    key: {
      pattern: RegExp(
        "((?:^|[:\\\\-,[{\\r\\n?])[ \\t]*(?:<<prop>>[ \\t]+)?)<<key>>(?=\\\\s*:\\\\s)".replace(
          /<<prop>>/g,
          function () {
            return t;
          },
        ).replace(/<<key>>/g, function () {
          return "(?:" + a + "|" + d + ")";
        }),
      ),
      lookbehind: !0,
      greedy: !0,
      alias: "atrule",
    },
    directive: { pattern: /(^[ \\t]*)%.+/m, lookbehind: !0, alias: "important" },
    datetime: {
      pattern: o(
        "\\\\d{4}-\\\\d\\\\d?-\\\\d\\\\d?(?:[tT]|[ \\t]+)\\\\d\\\\d?:\\\\d{2}:\\\\d{2}(?:\\\\.\\\\d*)?(?:[ \\t]*(?:Z|[-+]\\\\d\\\\d?(?::\\\\d{2})?))?|\\\\d{4}-\\\\d{2}-\\\\d{2}|\\\\d\\\\d?:\\\\d{2}(?::\\\\d{2}(?:\\\\.\\\\d*)?)?",
      ),
      lookbehind: !0,
      alias: "number",
    },
    boolean: { pattern: o("false|true", "i"), lookbehind: !0, alias: "important" },
    null: { pattern: o("null|~", "i"), lookbehind: !0, alias: "important" },
    string: { pattern: o(d), lookbehind: !0, greedy: !0 },
    number: {
      pattern: o(
        "[+-]?(?:0x[\\\\da-f]+|0o[0-7]+|(?:\\\\d+(?:\\\\.\\\\d*)?|\\\\.\\\\d+)(?:e[+-]?\\\\d+)?|\\\\.inf|\\\\.nan)",
        "i",
      ),
      lookbehind: !0,
    },
    tag: r,
    important: n,
    punctuation: /---|[:[\\]{}\\-,|>?]|\\.\\.\\./,
  }, e.languages.yml = e.languages.yaml;
}(Prism);
`,
    isBinary: false,
  },
  "prism-lua.min.js": {
    content: `Prism.languages.lua = {
  comment: /^#!.+|--(?:\\[(=*)\\[[\\s\\S]*?\\]\\1\\]|.*)/m,
  string: {
    pattern: /(["'])(?:(?!\\1)[^\\\\\\r\\n]|\\\\z(?:\\r\\n|\\s)|\\\\(?:\\r\\n|[^z]))*\\1|\\[(=*)\\[[\\s\\S]*?\\]\\2\\]/,
    greedy: !0,
  },
  number:
    /\\b0x[a-f\\d]+(?:\\.[a-f\\d]*)?(?:p[+-]?\\d+)?\\b|\\b\\d+(?:\\.\\B|(?:\\.\\d*)?(?:e[+-]?\\d+)?\\b)|\\B\\.\\d+(?:e[+-]?\\d+)?\\b/i,
  keyword:
    /\\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\\b/,
  function: /(?!\\d)\\w+(?=\\s*(?:[({]))/,
  operator: [/[-+*%^&|#]|\\/\\/?|<[<=]?|>[>=]?|[=~]=?/, {
    pattern: /(^|[^.])\\.\\.(?!\\.)/,
    lookbehind: !0,
  }],
  punctuation: /[\\[\\](){},;]|\\.+|:+/,
};
`,
    isBinary: false,
  },
  "prism-typescript.min.js": {
    content: `!function (e) {
  e.languages.typescript = e.languages.extend("javascript", {
    "class-name": {
      pattern:
        /(\\b(?:class|extends|implements|instanceof|interface|new|type)\\s+)(?!keyof\\b)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?:\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
      lookbehind: !0,
      greedy: !0,
      inside: null,
    },
    builtin:
      /\\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\\b/,
  }),
    e.languages.typescript.keyword.push(
      /\\b(?:abstract|declare|is|keyof|readonly|require)\\b/,
      /\\b(?:asserts|infer|interface|module|namespace|type)\\b(?=\\s*(?:[{_$a-zA-Z\\xA0-\\uFFFF]|$))/,
      /\\btype\\b(?=\\s*(?:[\\{*]|$))/,
    ),
    delete e.languages.typescript.parameter,
    delete e.languages.typescript["literal-property"];
  var s = e.languages.extend("typescript", {});
  delete s["class-name"],
    e.languages.typescript["class-name"].inside = s,
    e.languages.insertBefore("typescript", "function", {
      decorator: {
        pattern: /@[$\\w\\xA0-\\uFFFF]+/,
        inside: { at: { pattern: /^@/, alias: "operator" }, function: /^[\\s\\S]+/ },
      },
      "generic-function": {
        pattern:
          /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\\s*\\()/,
        greedy: !0,
        inside: {
          function: /^#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*/,
          generic: { pattern: /<[\\s\\S]+/, alias: "class-name", inside: s },
        },
      },
    }),
    e.languages.ts = e.languages.typescript;
}(Prism);
`,
    isBinary: false,
  },
  "prism-rust.min.js": {
    content: `!function (e) {
  for (var a = "/\\\\*(?:[^*/]|\\\\*(?!/)|/(?!\\\\*)|<self>)*\\\\*/", t = 0; t < 2; t++) {
    a = a.replace(/<self>/g, function () {
      return a;
    });
  }
  a = a.replace(/<self>/g, function () {
    return "[^\\\\s\\\\S]";
  }),
    e.languages.rust = {
      comment: [{ pattern: RegExp("(^|[^\\\\\\\\])" + a), lookbehind: !0, greedy: !0 }, {
        pattern: /(^|[^\\\\:])\\/\\/.*/,
        lookbehind: !0,
        greedy: !0,
      }],
      string: { pattern: /b?"(?:\\\\[\\s\\S]|[^\\\\"])*"|b?r(#*)"(?:[^"]|"(?!\\1))*"\\1/, greedy: !0 },
      char: {
        pattern: /b?'(?:\\\\(?:x[0-7][\\da-fA-F]|u\\{(?:[\\da-fA-F]_*){1,6}\\}|.)|[^\\\\\\r\\n\\t'])'/,
        greedy: !0,
      },
      attribute: {
        pattern: /#!?\\[(?:[^\\[\\]"]|"(?:\\\\[\\s\\S]|[^\\\\"])*")*\\]/,
        greedy: !0,
        alias: "attr-name",
        inside: { string: null },
      },
      "closure-params": {
        pattern: /([=(,:]\\s*|\\bmove\\s*)\\|[^|]*\\||\\|[^|]*\\|(?=\\s*(?:\\{|->))/,
        lookbehind: !0,
        greedy: !0,
        inside: { "closure-punctuation": { pattern: /^\\||\\|$/, alias: "punctuation" }, rest: null },
      },
      "lifetime-annotation": { pattern: /'\\w+/, alias: "symbol" },
      "fragment-specifier": { pattern: /(\\$\\w+:)[a-z]+/, lookbehind: !0, alias: "punctuation" },
      variable: /\\$\\w+/,
      "function-definition": { pattern: /(\\bfn\\s+)\\w+/, lookbehind: !0, alias: "function" },
      "type-definition": {
        pattern: /(\\b(?:enum|struct|trait|type|union)\\s+)\\w+/,
        lookbehind: !0,
        alias: "class-name",
      },
      "module-declaration": [{
        pattern: /(\\b(?:crate|mod)\\s+)[a-z][a-z_\\d]*/,
        lookbehind: !0,
        alias: "namespace",
      }, {
        pattern:
          /(\\b(?:crate|self|super)\\s*)::\\s*[a-z][a-z_\\d]*\\b(?:\\s*::(?:\\s*[a-z][a-z_\\d]*\\s*::)*)?/,
        lookbehind: !0,
        alias: "namespace",
        inside: { punctuation: /::/ },
      }],
      keyword: [
        /\\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\\b/,
        /\\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\\b/,
      ],
      function: /\\b[a-z_]\\w*(?=\\s*(?:::\\s*<|\\())/,
      macro: { pattern: /\\b\\w+!/, alias: "property" },
      constant: /\\b[A-Z_][A-Z_\\d]+\\b/,
      "class-name": /\\b[A-Z]\\w*\\b/,
      namespace: {
        pattern: /(?:\\b[a-z][a-z_\\d]*\\s*::\\s*)*\\b[a-z][a-z_\\d]*\\s*::(?!\\s*<)/,
        inside: { punctuation: /::/ },
      },
      number:
        /\\b(?:0x[\\dA-Fa-f](?:_?[\\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\\d(?:_?\\d)*)?\\.)?\\d(?:_?\\d)*(?:[Ee][+-]?\\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\\b/,
      boolean: /\\b(?:false|true)\\b/,
      punctuation: /->|\\.\\.=|\\.{1,3}|::|[{}[\\];(),:]/,
      operator: /[-+*\\/%!^]=?|=[=>]?|&[&=]?|\\|[|=]?|<<?=?|>>?=?|[@?]/,
    },
    e.languages.rust["closure-params"].inside.rest = e.languages.rust,
    e.languages.rust.attribute.inside.string = e.languages.rust.string;
}(Prism);
`,
    isBinary: false,
  },
  "prism-sql.min.js": {
    content: `Prism.languages.sql = {
  comment: { pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|(?:--|\\/\\/|#).*)/, lookbehind: !0 },
  variable: [{ pattern: /@(["'\`])(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])+\\1/, greedy: !0 }, /@[\\w.$]+/],
  string: {
    pattern: /(^|[^@\\\\])("|')(?:\\\\[\\s\\S]|(?!\\2)[^\\\\]|\\2\\2)*\\2/,
    greedy: !0,
    lookbehind: !0,
  },
  identifier: {
    pattern: /(^|[^@\\\\])\`(?:\\\\[\\s\\S]|[^\`\\\\]|\`\`)*\`/,
    greedy: !0,
    lookbehind: !0,
    inside: { punctuation: /^\`|\`$/ },
  },
  function:
    /\\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\\s*\\()/i,
  keyword:
    /\\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\\b/i,
  boolean: /\\b(?:FALSE|NULL|TRUE)\\b/i,
  number: /\\b0x[\\da-f]+\\b|\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+\\b/i,
  operator:
    /[-+*\\/=%^~]|&&?|\\|\\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\\b/i,
  punctuation: /[;[\\]()\`,.]/,
};
`,
    isBinary: false,
  },
  "prism-dark.css": {
    content: `code[class*="language-"], pre[class*="language-"] {
  color: #fff;
  background: 0 0;
  text-shadow: 0 -0.1em 0.2em #000;
  font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
  font-size: 1em;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.5;
  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;
  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}
@media print {
  code[class*="language-"], pre[class*="language-"] {
    text-shadow: none;
  }
}
:not(pre) > code[class*="language-"], pre[class*="language-"] {
  background: #4c3f33;
}
pre[class*="language-"] {
  padding: 1em;
  margin: 0.5em 0;
  overflow: auto;
  border: 0.3em solid #7a6651;
  border-radius: 0.5em;
  box-shadow: 1px 1px 0.5em #000 inset;
}
:not(pre) > code[class*="language-"] {
  padding: 0.15em 0.2em 0.05em;
  border-radius: 0.3em;
  border: 0.13em solid #7a6651;
  box-shadow: 1px 1px 0.3em -0.1em #000 inset;
  white-space: normal;
}
.token.cdata, .token.comment, .token.doctype, .token.prolog {
  color: #997f66;
}
.token.punctuation {
  opacity: 0.7;
}
.token.namespace {
  opacity: 0.7;
}
.token.boolean, .token.constant, .token.number, .token.property, .token.symbol, .token.tag {
  color: #d1939e;
}
.token.attr-name, .token.builtin, .token.char, .token.inserted, .token.selector, .token.string {
  color: #bce051;
}
.language-css .token.string,
.style .token.string,
.token.entity,
.token.operator,
.token.url,
.token.variable {
  color: #f4b73d;
}
.token.atrule, .token.attr-value, .token.keyword {
  color: #d1939e;
}
.token.important, .token.regex {
  color: #e90;
}
.token.bold, .token.important {
  font-weight: 700;
}
.token.italic {
  font-style: italic;
}
.token.entity {
  cursor: help;
}
.token.deleted {
  color: red;
}
`,
    isBinary: false,
  },
  "prism.min.js": {
    content: `/**
 * Minified by jsDelivr using Terser v5.37.0.
 * Original file: /npm/prismjs@1.29.0/prism.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
var _self = "undefined" != typeof window
    ? window
    : "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope
    ? self
    : {},
  Prism = function (e) {
    var t = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i,
      n = 0,
      a = {},
      r = {
        manual: e.Prism && e.Prism.manual,
        disableWorkerMessageHandler: e.Prism && e.Prism.disableWorkerMessageHandler,
        util: {
          encode: function e(t) {
            return t instanceof s
              ? new s(t.type, e(t.content), t.alias)
              : Array.isArray(t)
              ? t.map(e)
              : t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\\u00a0/g, " ");
          },
          type: function (e) {
            return Object.prototype.toString.call(e).slice(8, -1);
          },
          objId: function (e) {
            return e.__id || Object.defineProperty(e, "__id", { value: ++n }), e.__id;
          },
          clone: function e(t, n) {
            var a, s;
            switch (n = n || {}, r.util.type(t)) {
              case "Object":
                if (s = r.util.objId(t), n[s]) return n[s];
                for (var i in a = {}, n[s] = a, t) t.hasOwnProperty(i) && (a[i] = e(t[i], n));
                return a;
              case "Array":
                return s = r.util.objId(t),
                  n[s] ? n[s] : (a = [],
                    n[s] = a,
                    t.forEach(function (t, r) {
                      a[r] = e(t, n);
                    }),
                    a);
              default:
                return t;
            }
          },
          getLanguage: function (e) {
            for (; e;) {
              var n = t.exec(e.className);
              if (n) return n[1].toLowerCase();
              e = e.parentElement;
            }
            return "none";
          },
          setLanguage: function (e, n) {
            e.className = e.className.replace(RegExp(t, "gi"), ""),
              e.classList.add("language-" + n);
          },
          currentScript: function () {
            if ("undefined" == typeof document) return null;
            if ("currentScript" in document) return document.currentScript;
            try {
              throw new Error();
            } catch (a) {
              var e = (/at [^(\\r\\n]*\\((.*):[^:]+:[^:]+\\)$/i.exec(a.stack) || [])[1];
              if (e) {
                var t = document.getElementsByTagName("script");
                for (var n in t) if (t[n].src == e) return t[n];
              }
              return null;
            }
          },
          isActive: function (e, t, n) {
            for (var a = "no-" + t; e;) {
              var r = e.classList;
              if (r.contains(t)) return !0;
              if (r.contains(a)) return !1;
              e = e.parentElement;
            }
            return !!n;
          },
        },
        languages: {
          plain: a,
          plaintext: a,
          text: a,
          txt: a,
          extend: function (e, t) {
            var n = r.util.clone(r.languages[e]);
            for (var a in t) n[a] = t[a];
            return n;
          },
          insertBefore: function (e, t, n, a) {
            var s = (a = a || r.languages)[e], i = {};
            for (var o in s) {
              if (s.hasOwnProperty(o)) {
                if (o == t) { for (var l in n) n.hasOwnProperty(l) && (i[l] = n[l]); }
                n.hasOwnProperty(o) || (i[o] = s[o]);
              }
            }
            var u = a[e];
            return a[e] = i,
              r.languages.DFS(r.languages, function (t, n) {
                n === u && t != e && (this[t] = i);
              }),
              i;
          },
          DFS: function e(t, n, a, s) {
            s = s || {};
            var i = r.util.objId;
            for (var o in t) {
              if (t.hasOwnProperty(o)) {
                n.call(t, o, t[o], a || o);
                var l = t[o], u = r.util.type(l);
                "Object" !== u || s[i(l)]
                  ? "Array" !== u || s[i(l)] || (s[i(l)] = !0, e(l, n, o, s))
                  : (s[i(l)] = !0, e(l, n, null, s));
              }
            }
          },
        },
        plugins: {},
        highlightAll: function (e, t) {
          r.highlightAllUnder(document, e, t);
        },
        highlightAllUnder: function (e, t, n) {
          var a = {
            callback: n,
            container: e,
            selector:
              'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code',
          };
          r.hooks.run("before-highlightall", a),
            a.elements = Array.prototype.slice.apply(a.container.querySelectorAll(a.selector)),
            r.hooks.run("before-all-elements-highlight", a);
          for (var s, i = 0; s = a.elements[i++];) r.highlightElement(s, !0 === t, a.callback);
        },
        highlightElement: function (t, n, a) {
          var s = r.util.getLanguage(t), i = r.languages[s];
          r.util.setLanguage(t, s);
          var o = t.parentElement;
          o && "pre" === o.nodeName.toLowerCase() && r.util.setLanguage(o, s);
          var l = { element: t, language: s, grammar: i, code: t.textContent };
          function u(e) {
            l.highlightedCode = e,
              r.hooks.run("before-insert", l),
              l.element.innerHTML = l.highlightedCode,
              r.hooks.run("after-highlight", l),
              r.hooks.run("complete", l),
              a && a.call(l.element);
          }
          if (
            r.hooks.run("before-sanity-check", l),
              (o = l.element.parentElement) && "pre" === o.nodeName.toLowerCase() &&
              !o.hasAttribute("tabindex") && o.setAttribute("tabindex", "0"),
              !l.code
          ) return r.hooks.run("complete", l), void (a && a.call(l.element));
          if (r.hooks.run("before-highlight", l), l.grammar) {
            if (n && e.Worker) {
              var g = new Worker(r.filename);
              g.onmessage = function (e) {
                u(e.data);
              },
                g.postMessage(
                  JSON.stringify({ language: l.language, code: l.code, immediateClose: !0 }),
                );
            } else u(r.highlight(l.code, l.grammar, l.language));
          } else u(r.util.encode(l.code));
        },
        highlight: function (e, t, n) {
          var a = { code: e, grammar: t, language: n };
          if (r.hooks.run("before-tokenize", a), !a.grammar) {
            throw new Error('The language "' + a.language + '" has no grammar.');
          }
          return a.tokens = r.tokenize(a.code, a.grammar),
            r.hooks.run("after-tokenize", a),
            s.stringify(r.util.encode(a.tokens), a.language);
        },
        tokenize: function (e, t) {
          var n = t.rest;
          if (n) {
            for (var a in n) t[a] = n[a];
            delete t.rest;
          }
          var r = new l();
          return u(r, r.head, e),
            o(e, r, t, r.head, 0),
            function (e) {
              var t = [], n = e.head.next;
              for (; n !== e.tail;) t.push(n.value), n = n.next;
              return t;
            }(r);
        },
        hooks: {
          all: {},
          add: function (e, t) {
            var n = r.hooks.all;
            n[e] = n[e] || [], n[e].push(t);
          },
          run: function (e, t) {
            var n = r.hooks.all[e];
            if (n && n.length) { for (var a, s = 0; a = n[s++];) a(t); }
          },
        },
        Token: s,
      };
    function s(e, t, n, a) {
      this.type = e, this.content = t, this.alias = n, this.length = 0 | (a || "").length;
    }
    function i(e, t, n, a) {
      e.lastIndex = t;
      var r = e.exec(n);
      if (r && a && r[1]) {
        var s = r[1].length;
        r.index += s, r[0] = r[0].slice(s);
      }
      return r;
    }
    function o(e, t, n, a, l, c) {
      for (var d in n) {
        if (n.hasOwnProperty(d) && n[d]) {
          var p = n[d];
          p = Array.isArray(p) ? p : [p];
          for (var m = 0; m < p.length; ++m) {
            if (c && c.cause == d + "," + m) return;
            var h = p[m], f = h.inside, v = !!h.lookbehind, b = !!h.greedy, y = h.alias;
            if (b && !h.pattern.global) {
              var F = h.pattern.toString().match(/[imsuy]*$/)[0];
              h.pattern = RegExp(h.pattern.source, F + "g");
            }
            for (
              var x = h.pattern || h, k = a.next, w = l;
              k !== t.tail && !(c && w >= c.reach);
              w += k.value.length, k = k.next
            ) {
              var A = k.value;
              if (t.length > e.length) return;
              if (!(A instanceof s)) {
                var P, $ = 1;
                if (b) {
                  if (!(P = i(x, w, e, v)) || P.index >= e.length) break;
                  var S = P.index, E = P.index + P[0].length, _ = w;
                  for (_ += k.value.length; S >= _;) _ += (k = k.next).value.length;
                  if (w = _ -= k.value.length, k.value instanceof s) continue;
                  for (
                    var j = k;
                    j !== t.tail && (_ < E || "string" == typeof j.value);
                    j = j.next
                  ) $++, _ += j.value.length;
                  $--, A = e.slice(w, _), P.index -= w;
                } else if (!(P = i(x, 0, A, v))) continue;
                S = P.index;
                var C = P[0], L = A.slice(0, S), z = A.slice(S + C.length), O = w + A.length;
                c && O > c.reach && (c.reach = O);
                var T = k.prev;
                if (
                  L && (T = u(t, T, L), w += L.length),
                    g(t, T, $),
                    k = u(t, T, new s(d, f ? r.tokenize(C, f) : C, y, C)),
                    z && u(t, k, z),
                    $ > 1
                ) {
                  var M = { cause: d + "," + m, reach: O };
                  o(e, t, n, k.prev, w, M), c && M.reach > c.reach && (c.reach = M.reach);
                }
              }
            }
          }
        }
      }
    }
    function l() {
      var e = { value: null, prev: null, next: null }, t = { value: null, prev: e, next: null };
      e.next = t, this.head = e, this.tail = t, this.length = 0;
    }
    function u(e, t, n) {
      var a = t.next, r = { value: n, prev: t, next: a };
      return t.next = r, a.prev = r, e.length++, r;
    }
    function g(e, t, n) {
      for (var a = t.next, r = 0; r < n && a !== e.tail; r++) a = a.next;
      t.next = a, a.prev = t, e.length -= r;
    }
    if (
      e.Prism = r,
        s.stringify = function e(t, n) {
          if ("string" == typeof t) return t;
          if (Array.isArray(t)) {
            var a = "";
            return t.forEach(function (t) {
              a += e(t, n);
            }),
              a;
          }
          var s = {
              type: t.type,
              content: e(t.content, n),
              tag: "span",
              classes: ["token", t.type],
              attributes: {},
              language: n,
            },
            i = t.alias;
          i && (Array.isArray(i) ? Array.prototype.push.apply(s.classes, i) : s.classes.push(i)),
            r.hooks.run("wrap", s);
          var o = "";
          for (var l in s.attributes) {
            o += " " + l + '="' +
              (s.attributes[l] || "").replace(/"/g, "&quot;") + '"';
          }
          return "<" + s.tag + ' class="' + s.classes.join(" ") + '"' + o + ">" + s.content + "</" +
            s.tag + ">";
        },
        !e.document
    ) {
      return e.addEventListener
        ? (r.disableWorkerMessageHandler || e.addEventListener("message", function (t) {
          var n = JSON.parse(t.data), a = n.language, s = n.code, i = n.immediateClose;
          e.postMessage(r.highlight(s, r.languages[a], a)), i && e.close();
        }, !1),
          r)
        : r;
    }
    var c = r.util.currentScript();
    function d() {
      r.manual || r.highlightAll();
    }
    if (c && (r.filename = c.src, c.hasAttribute("data-manual") && (r.manual = !0)), !r.manual) {
      var p = document.readyState;
      "loading" === p || "interactive" === p && c && c.defer
        ? document.addEventListener("DOMContentLoaded", d)
        : window.requestAnimationFrame
        ? window.requestAnimationFrame(d)
        : window.setTimeout(d, 16);
    }
    return r;
  }(_self);
/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */ "undefined" != typeof module && module.exports && (module.exports = Prism),
  "undefined" != typeof global && (global.Prism = Prism),
  Prism.languages.markup = {
    comment: { pattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/, greedy: !0 },
    prolog: { pattern: /<\\?[\\s\\S]+?\\?>/, greedy: !0 },
    doctype: {
      pattern:
        /<!DOCTYPE(?:[^>"'[\\]]|"[^"]*"|'[^']*')+(?:\\[(?:[^<"'\\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,
      greedy: !0,
      inside: {
        "internal-subset": {
          pattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,
          lookbehind: !0,
          greedy: !0,
          inside: null,
        },
        string: { pattern: /"[^"]*"|'[^']*'/, greedy: !0 },
        punctuation: /^<!|>$|[[\\]]/,
        "doctype-tag": /^DOCTYPE/i,
        name: /[^\\s<>'"]+/,
      },
    },
    cdata: { pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i, greedy: !0 },
    tag: {
      pattern:
        /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:"[^"]*"|'[^']*'|[^\\s'">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,
      greedy: !0,
      inside: {
        tag: {
          pattern: /^<\\/?[^\\s>\\/]+/,
          inside: { punctuation: /^<\\/?/, namespace: /^[^\\s>\\/:]+:/ },
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\\s*(?:"[^"]*"|'[^']*'|[^\\s'">=]+)/,
          inside: {
            punctuation: [{ pattern: /^=/, alias: "attr-equals" }, {
              pattern: /^(\\s*)["']|["']$/,
              lookbehind: !0,
            }],
          },
        },
        punctuation: /\\/?>/,
        "attr-name": { pattern: /[^\\s>\\/]+/, inside: { namespace: /^[^\\s>\\/:]+:/ } },
      },
    },
    entity: [{ pattern: /&[\\da-z]{1,8};/i, alias: "named-entity" }, /&#x?[\\da-f]{1,8};/i],
  },
  Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity,
  Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup,
  Prism.hooks.add("wrap", function (e) {
    "entity" === e.type && (e.attributes.title = e.content.replace(/&amp;/, "&"));
  }),
  Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
    value: function (e, t) {
      var n = {};
      n["language-" + t] = {
        pattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,
        lookbehind: !0,
        inside: Prism.languages[t],
      }, n.cdata = /^<!\\[CDATA\\[|\\]\\]>$/i;
      var a = { "included-cdata": { pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i, inside: n } };
      a["language-" + t] = { pattern: /[\\s\\S]+/, inside: Prism.languages[t] };
      var r = {};
      r[e] = {
        pattern: RegExp(
          /(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/
            .source.replace(/__/g, function () {
              return e;
            }),
          "i",
        ),
        lookbehind: !0,
        greedy: !0,
        inside: a,
      }, Prism.languages.insertBefore("markup", "cdata", r);
    },
  }),
  Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
    value: function (e, t) {
      Prism.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\\s])/.source + "(?:" + e + ")" +
            /\\s*=\\s*(?:"[^"]*"|'[^']*'|[^\\s'">=]+(?=[\\s>]))/.source,
          "i",
        ),
        lookbehind: !0,
        inside: {
          "attr-name": /^[^\\s=]+/,
          "attr-value": {
            pattern: /=[\\s\\S]+/,
            inside: {
              value: {
                pattern: /(^=\\s*(["']|(?!["'])))\\S[\\s\\S]*(?=\\2$)/,
                lookbehind: !0,
                alias: [t, "language-" + t],
                inside: Prism.languages[t],
              },
              punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/],
            },
          },
        },
      });
    },
  }),
  Prism.languages.html = Prism.languages.markup,
  Prism.languages.mathml = Prism.languages.markup,
  Prism.languages.svg = Prism.languages.markup,
  Prism.languages.xml = Prism.languages.extend("markup", {}),
  Prism.languages.ssml = Prism.languages.xml,
  Prism.languages.atom = Prism.languages.xml,
  Prism.languages.rss = Prism.languages.xml,
  function (e) {
    var t = /(?:"(?:\\\\(?:\\r\\n|[\\s\\S])|[^"\\\\\\r\\n])*"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;
    e.languages.css = {
      comment: /\\/\\*[\\s\\S]*?\\*\\//,
      atrule: {
        pattern: RegExp(
          "@[\\\\w-](?:" + /[^;{\\s"']|\\s+(?!\\s)/.source + "|" + t.source + ")*?" +
            /(?:;|(?=\\s*\\{))/.source,
        ),
        inside: {
          rule: /^@[\\w-]+/,
          "selector-function-argument": {
            pattern:
              /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,
            lookbehind: !0,
            alias: "selector",
          },
          keyword: { pattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/, lookbehind: !0 },
        },
      },
      url: {
        pattern: RegExp(
          "\\\\burl\\\\((?:" + t.source + "|" + /(?:[^\\\\\\r\\n()"']|\\\\[\\s\\S])*/.source + ")\\\\)",
          "i",
        ),
        greedy: !0,
        inside: {
          function: /^url/i,
          punctuation: /^\\(|\\)$/,
          string: { pattern: RegExp("^" + t.source + "$"), alias: "url" },
        },
      },
      selector: {
        pattern: RegExp(
          "(^|[{}\\\\s])[^{}\\\\s](?:[^{};\\"'\\\\s]|\\\\s+(?![\\\\s{])|" + t.source + ")*(?=\\\\s*\\\\{)",
        ),
        lookbehind: !0,
      },
      string: { pattern: t, greedy: !0 },
      property: {
        pattern:
          /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,
        lookbehind: !0,
      },
      important: /!important\\b/i,
      function: { pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i, lookbehind: !0 },
      punctuation: /[(){};:,]/,
    }, e.languages.css.atrule.inside.rest = e.languages.css;
    var n = e.languages.markup;
    n && (n.tag.addInlined("style", "css"), n.tag.addAttribute("style", "css"));
  }(Prism),
  Prism.languages.clike = {
    comment: [{ pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, lookbehind: !0, greedy: !0 }, {
      pattern: /(^|[^\\\\:])\\/\\/.*/,
      lookbehind: !0,
      greedy: !0,
    }],
    string: { pattern: /(["'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/, greedy: !0 },
    "class-name": {
      pattern:
        /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,
      lookbehind: !0,
      inside: { punctuation: /[.\\\\]/ },
    },
    keyword:
      /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,
    boolean: /\\b(?:false|true)\\b/,
    function: /\\b\\w+(?=\\()/,
    number: /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,
    punctuation: /[{}[\\];(),.:]/,
  },
  Prism.languages.javascript = Prism.languages.extend("clike", {
    "class-name": [Prism.languages.clike["class-name"], {
      pattern:
        /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,
      lookbehind: !0,
    }],
    keyword: [{ pattern: /((?:^|\\})\\s*)catch\\b/, lookbehind: !0 }, {
      pattern:
        /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,
      lookbehind: !0,
    }],
    function:
      /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,
    number: {
      pattern: RegExp(
        /(^|[^\\w$])/.source + "(?:" + /NaN|Infinity/.source + "|" +
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" +
          /0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source + "|" + /\\d+(?:_\\d+)*n/.source + "|" +
          /(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/
            .source +
          ")" + /(?![\\w$])/.source,
      ),
      lookbehind: !0,
    },
    operator:
      /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/,
  }),
  Prism.languages.javascript["class-name"][0].pattern =
    /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/,
  Prism.languages.insertBefore("javascript", "keyword", {
    regex: {
      pattern: RegExp(
        /((?:^|[^$\\w\\xA0-\\uFFFF."'\\])\\s]|\\b(?:return|yield))\\s*)/.source + /\\//.source + "(?:" +
          /(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}/.source + "|" +
          /(?:\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}v[dgimyus]{0,7}/
            .source +
          ")" + /(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/.source,
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        "regex-source": {
          pattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,
          lookbehind: !0,
          alias: "language-regex",
          inside: Prism.languages.regex,
        },
        "regex-delimiter": /^\\/|\\/$/,
        "regex-flags": /^[a-z]+$/,
      },
    },
    "function-variable": {
      pattern:
        /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,
      alias: "function",
    },
    parameter: [{
      pattern:
        /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,
      lookbehind: !0,
      inside: Prism.languages.javascript,
    }, {
      pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,
      lookbehind: !0,
      inside: Prism.languages.javascript,
    }, {
      pattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,
      lookbehind: !0,
      inside: Prism.languages.javascript,
    }, {
      pattern:
        /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,
      lookbehind: !0,
      inside: Prism.languages.javascript,
    }],
    constant: /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/,
  }),
  Prism.languages.insertBefore("javascript", "string", {
    hashbang: { pattern: /^#!.*/, greedy: !0, alias: "comment" },
    "template-string": {
      pattern: /\`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\\`])*\`/,
      greedy: !0,
      inside: {
        "template-punctuation": { pattern: /^\`|\`$/, alias: "string" },
        interpolation: {
          pattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,
          lookbehind: !0,
          inside: {
            "interpolation-punctuation": { pattern: /^\\$\\{|\\}$/, alias: "punctuation" },
            rest: Prism.languages.javascript,
          },
        },
        string: /[\\s\\S]+/,
      },
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \\t]*)(["'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,
      lookbehind: !0,
      greedy: !0,
      alias: "property",
    },
  }),
  Prism.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,
      lookbehind: !0,
      alias: "property",
    },
  }),
  Prism.languages.markup &&
  (Prism.languages.markup.tag.addInlined("script", "javascript"),
    Prism.languages.markup.tag.addAttribute(
      /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/
        .source,
      "javascript",
    )),
  Prism.languages.js = Prism.languages.javascript,
  function () {
    if (void 0 !== Prism && "undefined" != typeof document) {
      Element.prototype.matches ||
        (Element.prototype.matches = Element.prototype.msMatchesSelector ||
          Element.prototype.webkitMatchesSelector);
      var e = {
          js: "javascript",
          py: "python",
          rb: "ruby",
          ps1: "powershell",
          psm1: "powershell",
          sh: "bash",
          bat: "batch",
          h: "c",
          tex: "latex",
        },
        t = "data-src-status",
        n = "loading",
        a = "loaded",
        r = "pre[data-src]:not([" + t + '="' + a + '"]):not([' + t + '="' + n + '"])';
      Prism.hooks.add("before-highlightall", function (e) {
        e.selector += ", " + r;
      }),
        Prism.hooks.add("before-sanity-check", function (s) {
          var i = s.element;
          if (i.matches(r)) {
            s.code = "", i.setAttribute(t, n);
            var o = i.appendChild(document.createElement("CODE"));
            o.textContent = "Loading";
            var l = i.getAttribute("data-src"), u = s.language;
            if ("none" === u) {
              var g = (/\\.(\\w+)$/.exec(l) || [, "none"])[1];
              u = e[g] || g;
            }
            Prism.util.setLanguage(o, u), Prism.util.setLanguage(i, u);
            var c = Prism.plugins.autoloader;
            c && c.loadLanguages(u),
              function (e, t, n) {
                var a = new XMLHttpRequest();
                a.open("GET", e, !0),
                  a.onreadystatechange = function () {
                    4 == a.readyState &&
                      (a.status < 400 && a.responseText
                        ? t(a.responseText)
                        : a.status >= 400
                        ? n(" Error " + a.status + " while fetching file: " + a.statusText)
                        : n(" Error: File does not exist or is empty"));
                  },
                  a.send(null);
              }(l, function (e) {
                i.setAttribute(t, a);
                var n = function (e) {
                  var t = /^\\s*(\\d+)\\s*(?:(,)\\s*(?:(\\d+)\\s*)?)?$/.exec(e || "");
                  if (t) {
                    var n = Number(t[1]), a = t[2], r = t[3];
                    return a ? r ? [n, Number(r)] : [n, void 0] : [n, n];
                  }
                }(i.getAttribute("data-range"));
                if (n) {
                  var r = e.split(/\\r\\n?|\\n/g), s = n[0], l = null == n[1] ? r.length : n[1];
                  s < 0 && (s += r.length),
                    s = Math.max(0, Math.min(s - 1, r.length)),
                    l < 0 && (l += r.length),
                    l = Math.max(0, Math.min(l, r.length)),
                    e = r.slice(s, l).join("\\n"),
                    i.hasAttribute("data-start") || i.setAttribute("data-start", String(s + 1));
                }
                o.textContent = e, Prism.highlightElement(o);
              }, function (e) {
                i.setAttribute(t, "failed"), o.textContent = e;
              });
          }
        }),
        Prism.plugins.fileHighlight = {
          highlight: function (e) {
            for (var t, n = (e || document).querySelectorAll(r), a = 0; t = n[a++];) {
              Prism.highlightElement(t);
            }
          },
        };
      var s = !1;
      Prism.fileHighlight = function () {
        s ||
        (console.warn(
          "Prism.fileHighlight is deprecated. Use \`Prism.plugins.fileHighlight.highlight\` instead.",
        ),
          s = !0), Prism.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    }
  }();
//# sourceMappingURL=/sm/1f55244a569fc0911044b5e4725a97872b6d85b0662a3429a809bb62f713c381.map
`,
    isBinary: false,
  },
  "prism-markdown.min.js": {
    content: `!function (n) {
  function e(n) {
    return n = n.replace(/<inner>/g, function () {
      return "(?:\\\\\\\\.|[^\\\\\\\\\\n\\r]|(?:\\n|\\r\\n?)(?![\\r\\n]))";
    }),
      RegExp("((?:^|[^\\\\\\\\])(?:\\\\\\\\{2})*)(?:" + n + ")");
  }
  var t = "(?:\\\\\\\\.|\`\`(?:[^\`\\r\\n]|\`(?!\`))+\`\`|\`[^\`\\r\\n]+\`|[^\\\\\\\\|\\r\\n\`])+",
    a = "\\\\|?__(?:\\\\|__)+\\\\|?(?:(?:\\n|\\r\\n?)|(?![^]))".replace(/__/g, function () {
      return t;
    }),
    i = "\\\\|?[ \\t]*:?-{3,}:?[ \\t]*(?:\\\\|[ \\t]*:?-{3,}:?[ \\t]*)+\\\\|?(?:\\n|\\r\\n?)";
  n.languages.markdown = n.languages.extend("markup", {}),
    n.languages.insertBefore("markdown", "prolog", {
      "front-matter-block": {
        pattern: /(^(?:\\s*[\\r\\n])?)---(?!.)[\\s\\S]*?[\\r\\n]---(?!.)/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          punctuation: /^---|---$/,
          "front-matter": {
            pattern: /\\S+(?:\\s+\\S+)*/,
            alias: ["yaml", "language-yaml"],
            inside: n.languages.yaml,
          },
        },
      },
      blockquote: { pattern: /^>(?:[\\t ]*>)*/m, alias: "punctuation" },
      table: {
        pattern: RegExp("^" + a + i + "(?:" + a + ")*", "m"),
        inside: {
          "table-data-rows": {
            pattern: RegExp("^(" + a + i + ")(?:" + a + ")*$"),
            lookbehind: !0,
            inside: {
              "table-data": { pattern: RegExp(t), inside: n.languages.markdown },
              punctuation: /\\|/,
            },
          },
          "table-line": {
            pattern: RegExp("^(" + a + ")" + i + "$"),
            lookbehind: !0,
            inside: { punctuation: /\\||:?-{3,}:?/ },
          },
          "table-header-row": {
            pattern: RegExp("^" + a + "$"),
            inside: {
              "table-header": {
                pattern: RegExp(t),
                alias: "important",
                inside: n.languages.markdown,
              },
              punctuation: /\\|/,
            },
          },
        },
      },
      code: [{
        pattern:
          /((?:^|\\n)[ \\t]*\\n|(?:^|\\r\\n?)[ \\t]*\\r\\n?)(?: {4}|\\t).+(?:(?:\\n|\\r\\n?)(?: {4}|\\t).+)*/,
        lookbehind: !0,
        alias: "keyword",
      }, {
        pattern: /^\`\`\`[\\s\\S]*?^\`\`\`$/m,
        greedy: !0,
        inside: {
          "code-block": {
            pattern: /^(\`\`\`.*(?:\\n|\\r\\n?))[\\s\\S]+?(?=(?:\\n|\\r\\n?)^\`\`\`$)/m,
            lookbehind: !0,
          },
          "code-language": { pattern: /^(\`\`\`).+/, lookbehind: !0 },
          punctuation: /\`\`\`/,
        },
      }],
      title: [{
        pattern: /\\S.*(?:\\n|\\r\\n?)(?:==+|--+)(?=[ \\t]*$)/m,
        alias: "important",
        inside: { punctuation: /==+$|--+$/ },
      }, {
        pattern: /(^\\s*)#.+/m,
        lookbehind: !0,
        alias: "important",
        inside: { punctuation: /^#+|#+$/ },
      }],
      hr: {
        pattern: /(^\\s*)([*-])(?:[\\t ]*\\2){2,}(?=\\s*$)/m,
        lookbehind: !0,
        alias: "punctuation",
      },
      list: { pattern: /(^\\s*)(?:[*+-]|\\d+\\.)(?=[\\t ].)/m, lookbehind: !0, alias: "punctuation" },
      "url-reference": {
        pattern:
          /!?\\[[^\\]]+\\]:[\\t ]+(?:\\S+|<(?:\\\\.|[^>\\\\])+>)(?:[\\t ]+(?:"(?:\\\\.|[^"\\\\])*"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\)))?/,
        inside: {
          variable: { pattern: /^(!?\\[)[^\\]]+/, lookbehind: !0 },
          string: /(?:"(?:\\\\.|[^"\\\\])*"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\))$/,
          punctuation: /^[\\[\\]!:]|[<>]/,
        },
        alias: "url",
      },
      bold: {
        pattern: e(
          "\\\\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\\\\b|\\\\*\\\\*(?:(?!\\\\*)<inner>|\\\\*(?:(?!\\\\*)<inner>)+\\\\*)+\\\\*\\\\*",
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          content: { pattern: /(^..)[\\s\\S]+(?=..$)/, lookbehind: !0, inside: {} },
          punctuation: /\\*\\*|__/,
        },
      },
      italic: {
        pattern: e(
          "\\\\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\\\\b|\\\\*(?:(?!\\\\*)<inner>|\\\\*\\\\*(?:(?!\\\\*)<inner>)+\\\\*\\\\*)+\\\\*",
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          content: { pattern: /(^.)[\\s\\S]+(?=.$)/, lookbehind: !0, inside: {} },
          punctuation: /[*_]/,
        },
      },
      strike: {
        pattern: e("(~~?)(?:(?!~)<inner>)+\\\\2"),
        lookbehind: !0,
        greedy: !0,
        inside: {
          content: { pattern: /(^~~?)[\\s\\S]+(?=\\1$)/, lookbehind: !0, inside: {} },
          punctuation: /~~?/,
        },
      },
      "code-snippet": {
        pattern: /(^|[^\\\\\`])(?:\`\`[^\`\\r\\n]+(?:\`[^\`\\r\\n]+)*\`\`(?!\`)|\`[^\`\\r\\n]+\`(?!\`))/,
        lookbehind: !0,
        greedy: !0,
        alias: ["code", "keyword"],
      },
      url: {
        pattern: e(
          '!?\\\\[(?:(?!\\\\])<inner>)+\\\\](?:\\\\([^\\\\s)]+(?:[\\t ]+"(?:\\\\\\\\.|[^"\\\\\\\\])*")?\\\\)|[ \\t]?\\\\[(?:(?!\\\\])<inner>)+\\\\])',
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          operator: /^!/,
          content: { pattern: /(^\\[)[^\\]]+(?=\\])/, lookbehind: !0, inside: {} },
          variable: { pattern: /(^\\][ \\t]?\\[)[^\\]]+(?=\\]$)/, lookbehind: !0 },
          url: { pattern: /(^\\]\\()[^\\s)]+/, lookbehind: !0 },
          string: { pattern: /(^[ \\t]+)"(?:\\\\.|[^"\\\\])*"(?=\\)$)/, lookbehind: !0 },
        },
      },
    }),
    ["url", "bold", "italic", "strike"].forEach(function (e) {
      ["url", "bold", "italic", "strike", "code-snippet"].forEach(function (t) {
        e !== t && (n.languages.markdown[e].inside.content.inside[t] = n.languages.markdown[t]);
      });
    }),
    n.hooks.add("after-tokenize", function (n) {
      "markdown" !== n.language && "md" !== n.language || function n(e) {
        if (e && "string" != typeof e) {
          for (var t = 0, a = e.length; t < a; t++) {
            var i = e[t];
            if ("code" === i.type) {
              var r = i.content[1], o = i.content[3];
              if (
                r && o && "code-language" === r.type && "code-block" === o.type &&
                "string" == typeof r.content
              ) {
                var l = r.content.replace(/\\b#/g, "sharp").replace(/\\b\\+\\+/g, "pp"),
                  s = "language-" + (l = (/[a-z][\\w-]*/i.exec(l) || [""])[0].toLowerCase());
                o.alias
                  ? "string" == typeof o.alias ? o.alias = [o.alias, s] : o.alias.push(s)
                  : o.alias = [s];
              }
            } else n(i.content);
          }
        }
      }(n.tokens);
    }),
    n.hooks.add("wrap", function (e) {
      if ("code-block" === e.type) {
        for (var t = "", a = 0, i = e.classes.length; a < i; a++) {
          var s = e.classes[a], d = /language-(.+)/.exec(s);
          if (d) {
            t = d[1];
            break;
          }
        }
        var p = n.languages[t];
        if (p) {
          e.content = n.highlight(
            e.content.replace(r, "").replace(/&(\\w{1,8}|#x?[\\da-f]{1,8});/gi, function (n, e) {
              var t;
              return "#" === (e = e.toLowerCase())[0]
                ? (t = "x" === e[1] ? parseInt(e.slice(2), 16) : Number(e.slice(1)), l(t))
                : o[e] || n;
            }),
            p,
            t,
          );
        } else if (t && "none" !== t && n.plugins.autoloader) {
          var u = "md-" + (new Date()).valueOf() + "-" + Math.floor(1e16 * Math.random());
          e.attributes.id = u,
            n.plugins.autoloader.loadLanguages(t, function () {
              var e = document.getElementById(u);
              e && (e.innerHTML = n.highlight(e.textContent, n.languages[t], t));
            });
        }
      }
    });
  var r = RegExp(n.languages.markup.tag.pattern.source, "gi"),
    o = { amp: "&", lt: "<", gt: ">", quot: '"' },
    l = String.fromCodePoint || String.fromCharCode;
  n.languages.md = n.languages.markdown;
}(Prism);
`,
    isBinary: false,
  },
  "marked.min.js": {
    content: `/**
 * marked v14.1.4 - a markdown parser
 * Copyright (c) 2011-2024, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */
!function (e, t) {
  "object" == typeof exports && "undefined" != typeof module
    ? t(exports)
    : "function" == typeof define && define.amd
    ? define(["exports"], t)
    : t((e = "undefined" != typeof globalThis ? globalThis : e || self).marked = {});
}(this, function (e) {
  "use strict";
  function t() {
    return {
      async: !1,
      breaks: !1,
      extensions: null,
      gfm: !0,
      hooks: null,
      pedantic: !1,
      renderer: null,
      silent: !1,
      tokenizer: null,
      walkTokens: null,
    };
  }
  function n(t) {
    e.defaults = t;
  }
  e.defaults = {
    async: !1,
    breaks: !1,
    extensions: null,
    gfm: !0,
    hooks: null,
    pedantic: !1,
    renderer: null,
    silent: !1,
    tokenizer: null,
    walkTokens: null,
  };
  const s = /[&<>"']/,
    r = new RegExp(s.source, "g"),
    i = /[<>"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/,
    l = new RegExp(i.source, "g"),
    o = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" },
    a = (e) => o[e];
  function c(e, t) {
    if (t) { if (s.test(e)) return e.replace(r, a); }
    else if (i.test(e)) return e.replace(l, a);
    return e;
  }
  const h = /(^|[^\\[])\\^/g;
  function p(e, t) {
    let n = "string" == typeof e ? e : e.source;
    t = t || "";
    const s = {
      replace: (e, t) => {
        let r = "string" == typeof t ? t : t.source;
        return r = r.replace(h, "$1"), n = n.replace(e, r), s;
      },
      getRegex: () => new RegExp(n, t),
    };
    return s;
  }
  function u(e) {
    try {
      e = encodeURI(e).replace(/%25/g, "%");
    } catch {
      return null;
    }
    return e;
  }
  const k = { exec: () => null };
  function g(e, t) {
    const n = e.replace(/\\|/g, (e, t, n) => {
      let s = !1, r = t;
      for (; --r >= 0 && "\\\\" === n[r];) s = !s;
      return s ? "|" : " |";
    }).split(/ \\|/);
    let s = 0;
    if (n[0].trim() || n.shift(), n.length > 0 && !n[n.length - 1].trim() && n.pop(), t) {
      if (n.length > t) {
        n.splice(t);
      } else for (; n.length < t;) n.push("");
    }
    for (; s < n.length; s++) n[s] = n[s].trim().replace(/\\\\\\|/g, "|");
    return n;
  }
  function f(e, t, n) {
    const s = e.length;
    if (0 === s) return "";
    let r = 0;
    for (; r < s;) {
      const i = e.charAt(s - r - 1);
      if (i !== t || n) {
        if (i === t || !n) break;
        r++;
      } else r++;
    }
    return e.slice(0, s - r);
  }
  function d(e, t, n, s) {
    const r = t.href, i = t.title ? c(t.title) : null, l = e[1].replace(/\\\\([\\[\\]])/g, "$1");
    if ("!" !== e[0].charAt(0)) {
      s.state.inLink = !0;
      const e = { type: "link", raw: n, href: r, title: i, text: l, tokens: s.inlineTokens(l) };
      return s.state.inLink = !1, e;
    }
    return { type: "image", raw: n, href: r, title: i, text: c(l) };
  }
  class x {
    options;
    rules;
    lexer;
    constructor(t) {
      this.options = t || e.defaults;
    }
    space(e) {
      const t = this.rules.block.newline.exec(e);
      if (t && t[0].length > 0) return { type: "space", raw: t[0] };
    }
    code(e) {
      const t = this.rules.block.code.exec(e);
      if (t) {
        const e = t[0].replace(/^(?: {1,4}| {0,3}\\t)/gm, "");
        return {
          type: "code",
          raw: t[0],
          codeBlockStyle: "indented",
          text: this.options.pedantic ? e : f(e, "\\n"),
        };
      }
    }
    fences(e) {
      const t = this.rules.block.fences.exec(e);
      if (t) {
        const e = t[0],
          n = function (e, t) {
            const n = e.match(/^(\\s+)(?:\`\`\`)/);
            if (null === n) return t;
            const s = n[1];
            return t.split("\\n").map((e) => {
              const t = e.match(/^\\s+/);
              if (null === t) return e;
              const [n] = t;
              return n.length >= s.length ? e.slice(s.length) : e;
            }).join("\\n");
          }(e, t[3] || "");
        return {
          type: "code",
          raw: e,
          lang: t[2] ? t[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : t[2],
          text: n,
        };
      }
    }
    heading(e) {
      const t = this.rules.block.heading.exec(e);
      if (t) {
        let e = t[2].trim();
        if (/#$/.test(e)) {
          const t = f(e, "#");
          this.options.pedantic ? e = t.trim() : t && !/ $/.test(t) || (e = t.trim());
        }
        return {
          type: "heading",
          raw: t[0],
          depth: t[1].length,
          text: e,
          tokens: this.lexer.inline(e),
        };
      }
    }
    hr(e) {
      const t = this.rules.block.hr.exec(e);
      if (t) return { type: "hr", raw: f(t[0], "\\n") };
    }
    blockquote(e) {
      const t = this.rules.block.blockquote.exec(e);
      if (t) {
        let e = f(t[0], "\\n").split("\\n"), n = "", s = "";
        const r = [];
        for (; e.length > 0;) {
          let t = !1;
          const i = [];
          let l;
          for (l = 0; l < e.length; l++) {
            if (/^ {0,3}>/.test(e[l])) i.push(e[l]), t = !0;
            else {
              if (t) break;
              i.push(e[l]);
            }
          }
          e = e.slice(l);
          const o = i.join("\\n"),
            a = o.replace(/\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g, "\\n    $1").replace(
              /^ {0,3}>[ \\t]?/gm,
              "",
            );
          n = n ? \`\${n}\\n\${o}\` : o, s = s ? \`\${s}\\n\${a}\` : a;
          const c = this.lexer.state.top;
          if (
            this.lexer.state.top = !0,
              this.lexer.blockTokens(a, r, !0),
              this.lexer.state.top = c,
              0 === e.length
          ) break;
          const h = r[r.length - 1];
          if ("code" === h?.type) break;
          if ("blockquote" === h?.type) {
            const t = h, i = t.raw + "\\n" + e.join("\\n"), l = this.blockquote(i);
            r[r.length - 1] = l,
              n = n.substring(0, n.length - t.raw.length) + l.raw,
              s = s.substring(0, s.length - t.text.length) + l.text;
            break;
          }
          if ("list" !== h?.type);
          else {
            const t = h, i = t.raw + "\\n" + e.join("\\n"), l = this.list(i);
            r[r.length - 1] = l,
              n = n.substring(0, n.length - h.raw.length) + l.raw,
              s = s.substring(0, s.length - t.raw.length) + l.raw,
              e = i.substring(r[r.length - 1].raw.length).split("\\n");
          }
        }
        return { type: "blockquote", raw: n, tokens: r, text: s };
      }
    }
    list(e) {
      let t = this.rules.block.list.exec(e);
      if (t) {
        let n = t[1].trim();
        const s = n.length > 1,
          r = {
            type: "list",
            raw: "",
            ordered: s,
            start: s ? +n.slice(0, -1) : "",
            loose: !1,
            items: [],
          };
        n = s ? \`\\\\d{1,9}\\\\\${n.slice(-1)}\` : \`\\\\\${n}\`,
          this.options.pedantic && (n = s ? n : "[*+-]");
        const i = new RegExp(\`^( {0,3}\${n})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))\`);
        let l = !1;
        for (; e;) {
          let n = !1, s = "", o = "";
          if (!(t = i.exec(e))) break;
          if (this.rules.block.hr.test(e)) break;
          s = t[0], e = e.substring(s.length);
          let a = t[2].split("\\n", 1)[0].replace(/^\\t+/, (e) => " ".repeat(3 * e.length)),
            c = e.split("\\n", 1)[0],
            h = !a.trim(),
            p = 0;
          if (
            this.options.pedantic
              ? (p = 2, o = a.trimStart())
              : h
              ? p = t[1].length + 1
              : (p = t[2].search(/[^ ]/), p = p > 4 ? 1 : p, o = a.slice(p), p += t[1].length),
              h && /^[ \\t]*$/.test(c) && (s += c + "\\n", e = e.substring(c.length + 1), n = !0),
              !n
          ) {
            const t = new RegExp(
                \`^ {0,\${Math.min(3, p - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))\`,
              ),
              n = new RegExp(
                \`^ {0,\${Math.min(3, p - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)\`,
              ),
              r = new RegExp(\`^ {0,\${Math.min(3, p - 1)}}(?:\\\`\\\`\\\`|~~~)\`),
              i = new RegExp(\`^ {0,\${Math.min(3, p - 1)}}#\`),
              l = new RegExp(\`^ {0,\${Math.min(3, p - 1)}}<(?:[a-z].*>|!--)\`, "i");
            for (; e;) {
              const u = e.split("\\n", 1)[0];
              let k;
              if (
                c = u,
                  this.options.pedantic
                    ? (c = c.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  "), k = c)
                    : k = c.replace(/\\t/g, "    "),
                  r.test(c)
              ) break;
              if (i.test(c)) break;
              if (l.test(c)) break;
              if (t.test(c)) break;
              if (n.test(c)) break;
              if (k.search(/[^ ]/) >= p || !c.trim()) o += "\\n" + k.slice(p);
              else {
                if (h) break;
                if (a.replace(/\\t/g, "    ").search(/[^ ]/) >= 4) break;
                if (r.test(a)) break;
                if (i.test(a)) break;
                if (n.test(a)) break;
                o += "\\n" + c;
              }
              h || c.trim() || (h = !0),
                s += u + "\\n",
                e = e.substring(u.length + 1),
                a = k.slice(p);
            }
          }
          r.loose || (l ? r.loose = !0 : /\\n[ \\t]*\\n[ \\t]*$/.test(s) && (l = !0));
          let u, k = null;
          this.options.gfm &&
          (k = /^\\[[ xX]\\] /.exec(o),
            k && (u = "[ ] " !== k[0], o = o.replace(/^\\[[ xX]\\] +/, ""))),
            r.items.push({
              type: "list_item",
              raw: s,
              task: !!k,
              checked: u,
              loose: !1,
              text: o,
              tokens: [],
            }),
            r.raw += s;
        }
        r.items[r.items.length - 1].raw = r.items[r.items.length - 1].raw.trimEnd(),
          r.items[r.items.length - 1].text = r.items[r.items.length - 1].text.trimEnd(),
          r.raw = r.raw.trimEnd();
        for (let e = 0; e < r.items.length; e++) {
          if (
            this.lexer.state.top = !1,
              r.items[e].tokens = this.lexer.blockTokens(r.items[e].text, []),
              !r.loose
          ) {
            const t = r.items[e].tokens.filter((e) => "space" === e.type),
              n = t.length > 0 && t.some((e) => /\\n.*\\n/.test(e.raw));
            r.loose = n;
          }
        }
        if (r.loose) { for (let e = 0; e < r.items.length; e++) r.items[e].loose = !0; }
        return r;
      }
    }
    html(e) {
      const t = this.rules.block.html.exec(e);
      if (t) {
        return {
          type: "html",
          block: !0,
          raw: t[0],
          pre: "pre" === t[1] || "script" === t[1] || "style" === t[1],
          text: t[0],
        };
      }
    }
    def(e) {
      const t = this.rules.block.def.exec(e);
      if (t) {
        const e = t[1].toLowerCase().replace(/\\s+/g, " "),
          n = t[2]
            ? t[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1")
            : "",
          s = t[3]
            ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1")
            : t[3];
        return { type: "def", tag: e, raw: t[0], href: n, title: s };
      }
    }
    table(e) {
      const t = this.rules.block.table.exec(e);
      if (!t) return;
      if (!/[:|]/.test(t[2])) return;
      const n = g(t[1]),
        s = t[2].replace(/^\\||\\| *$/g, "").split("|"),
        r = t[3] && t[3].trim() ? t[3].replace(/\\n[ \\t]*$/, "").split("\\n") : [],
        i = { type: "table", raw: t[0], header: [], align: [], rows: [] };
      if (n.length === s.length) {
        for (const e of s) {
          /^ *-+: *$/.test(e)
            ? i.align.push("right")
            : /^ *:-+: *$/.test(e)
            ? i.align.push("center")
            : /^ *:-+ *$/.test(e)
            ? i.align.push("left")
            : i.align.push(null);
        }
        for (let e = 0; e < n.length; e++) {
          i.header.push({
            text: n[e],
            tokens: this.lexer.inline(n[e]),
            header: !0,
            align: i.align[e],
          });
        }
        for (const e of r) {
          i.rows.push(
            g(e, i.header.length).map(
              (e, t) => ({ text: e, tokens: this.lexer.inline(e), header: !1, align: i.align[t] }),
            ),
          );
        }
        return i;
      }
    }
    lheading(e) {
      const t = this.rules.block.lheading.exec(e);
      if (t) {
        return {
          type: "heading",
          raw: t[0],
          depth: "=" === t[2].charAt(0) ? 1 : 2,
          text: t[1],
          tokens: this.lexer.inline(t[1]),
        };
      }
    }
    paragraph(e) {
      const t = this.rules.block.paragraph.exec(e);
      if (t) {
        const e = "\\n" === t[1].charAt(t[1].length - 1) ? t[1].slice(0, -1) : t[1];
        return { type: "paragraph", raw: t[0], text: e, tokens: this.lexer.inline(e) };
      }
    }
    text(e) {
      const t = this.rules.block.text.exec(e);
      if (t) return { type: "text", raw: t[0], text: t[0], tokens: this.lexer.inline(t[0]) };
    }
    escape(e) {
      const t = this.rules.inline.escape.exec(e);
      if (t) return { type: "escape", raw: t[0], text: c(t[1]) };
    }
    tag(e) {
      const t = this.rules.inline.tag.exec(e);
      if (t) {
        return !this.lexer.state.inLink && /^<a /i.test(t[0])
          ? this.lexer.state.inLink = !0
          : this.lexer.state.inLink && /^<\\/a>/i.test(t[0]) && (this.lexer.state.inLink = !1),
          !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(t[0])
            ? this.lexer.state.inRawBlock = !0
            : this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(t[0]) &&
              (this.lexer.state.inRawBlock = !1),
          {
            type: "html",
            raw: t[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            block: !1,
            text: t[0],
          };
      }
    }
    link(e) {
      const t = this.rules.inline.link.exec(e);
      if (t) {
        const e = t[2].trim();
        if (!this.options.pedantic && /^</.test(e)) {
          if (!/>$/.test(e)) return;
          const t = f(e.slice(0, -1), "\\\\");
          if ((e.length - t.length) % 2 == 0) return;
        } else {
          const e = function (e, t) {
            if (-1 === e.indexOf(t[1])) return -1;
            let n = 0;
            for (let s = 0; s < e.length; s++) {
              if ("\\\\" === e[s]) s++;
              else if (e[s] === t[0]) n++;
              else if (e[s] === t[1] && (n--, n < 0)) return s;
            }
            return -1;
          }(t[2], "()");
          if (e > -1) {
            const n = (0 === t[0].indexOf("!") ? 5 : 4) + t[1].length + e;
            t[2] = t[2].substring(0, e), t[0] = t[0].substring(0, n).trim(), t[3] = "";
          }
        }
        let n = t[2], s = "";
        if (this.options.pedantic) {
          const e = /^([^'"]*[^\\s])\\s+(['"])(.*)\\2/.exec(n);
          e && (n = e[1], s = e[3]);
        } else s = t[3] ? t[3].slice(1, -1) : "";
        return n = n.trim(),
          /^</.test(n) &&
          (n = this.options.pedantic && !/>$/.test(e) ? n.slice(1) : n.slice(1, -1)),
          d(
            t,
            {
              href: n ? n.replace(this.rules.inline.anyPunctuation, "$1") : n,
              title: s ? s.replace(this.rules.inline.anyPunctuation, "$1") : s,
            },
            t[0],
            this.lexer,
          );
      }
    }
    reflink(e, t) {
      let n;
      if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
        const e = t[(n[2] || n[1]).replace(/\\s+/g, " ").toLowerCase()];
        if (!e) {
          const e = n[0].charAt(0);
          return { type: "text", raw: e, text: e };
        }
        return d(n, e, n[0], this.lexer);
      }
    }
    emStrong(e, t, n = "") {
      let s = this.rules.inline.emStrongLDelim.exec(e);
      if (!s) return;
      if (s[3] && n.match(/[\\p{L}\\p{N}]/u)) return;
      if (!(s[1] || s[2] || "") || !n || this.rules.inline.punctuation.exec(n)) {
        const n = [...s[0]].length - 1;
        let r, i, l = n, o = 0;
        const a = "*" === s[0][0]
          ? this.rules.inline.emStrongRDelimAst
          : this.rules.inline.emStrongRDelimUnd;
        for (a.lastIndex = 0, t = t.slice(-1 * e.length + n); null != (s = a.exec(t));) {
          if (r = s[1] || s[2] || s[3] || s[4] || s[5] || s[6], !r) continue;
          if (i = [...r].length, s[3] || s[4]) {
            l += i;
            continue;
          }
          if ((s[5] || s[6]) && n % 3 && !((n + i) % 3)) {
            o += i;
            continue;
          }
          if (l -= i, l > 0) continue;
          i = Math.min(i, i + l + o);
          const t = [...s[0]][0].length, a = e.slice(0, n + s.index + t + i);
          if (Math.min(n, i) % 2) {
            const e = a.slice(1, -1);
            return { type: "em", raw: a, text: e, tokens: this.lexer.inlineTokens(e) };
          }
          const c = a.slice(2, -2);
          return { type: "strong", raw: a, text: c, tokens: this.lexer.inlineTokens(c) };
        }
      }
    }
    codespan(e) {
      const t = this.rules.inline.code.exec(e);
      if (t) {
        let e = t[2].replace(/\\n/g, " ");
        const n = /[^ ]/.test(e), s = /^ /.test(e) && / $/.test(e);
        return n && s && (e = e.substring(1, e.length - 1)),
          e = c(e, !0),
          { type: "codespan", raw: t[0], text: e };
      }
    }
    br(e) {
      const t = this.rules.inline.br.exec(e);
      if (t) return { type: "br", raw: t[0] };
    }
    del(e) {
      const t = this.rules.inline.del.exec(e);
      if (t) return { type: "del", raw: t[0], text: t[2], tokens: this.lexer.inlineTokens(t[2]) };
    }
    autolink(e) {
      const t = this.rules.inline.autolink.exec(e);
      if (t) {
        let e, n;
        return "@" === t[2] ? (e = c(t[1]), n = "mailto:" + e) : (e = c(t[1]), n = e), {
          type: "link",
          raw: t[0],
          text: e,
          href: n,
          tokens: [{ type: "text", raw: e, text: e }],
        };
      }
    }
    url(e) {
      let t;
      if (t = this.rules.inline.url.exec(e)) {
        let e, n;
        if ("@" === t[2]) e = c(t[0]), n = "mailto:" + e;
        else {
          let s;
          do {
            s = t[0], t[0] = this.rules.inline._backpedal.exec(t[0])?.[0] ?? "";
          } while (s !== t[0]);
          e = c(t[0]), n = "www." === t[1] ? "http://" + t[0] : t[0];
        }
        return {
          type: "link",
          raw: t[0],
          text: e,
          href: n,
          tokens: [{ type: "text", raw: e, text: e }],
        };
      }
    }
    inlineText(e) {
      const t = this.rules.inline.text.exec(e);
      if (t) {
        let e;
        return e = this.lexer.state.inRawBlock ? t[0] : c(t[0]),
          { type: "text", raw: t[0], text: e };
      }
    }
  }
  const b = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/,
    w = /(?:[*+-]|\\d{1,9}[.)])/,
    m = p(
      /^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,
    ).replace(/bull/g, w).replace(/blockCode/g, /(?: {4}| {0,3}\\t)/).replace(
      /fences/g,
      / {0,3}(?:\`{3,}|~{3,})/,
    ).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(
      /html/g,
      / {0,3}<[^\\n>]+>\\n/,
    ).getRegex(),
    y = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/,
    $ = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/,
    z = p(
      /^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/,
    ).replace("label", $).replace(
      "title",
      /(?:"(?:\\\\"?|[^"\\\\])*"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/,
    ).getRegex(),
    T = p(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/).replace(/bull/g, w).getRegex(),
    R =
      "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",
    _ = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/,
    A = p(
      "^ {0,3}(?:<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)|comment[^\\\\n]*(\\\\n+|$)|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$))",
      "i",
    ).replace("comment", _).replace("tag", R).replace(
      "attribute",
      / +[a-zA-Z:_][\\w.:-]*(?: *= *"[^"\\n]*"| *= *'[^'\\n]*'| *= *[^\\s"'=<>\`]+)?/,
    ).getRegex(),
    S = p(y).replace("hr", b).replace("heading", " {0,3}#{1,6}(?:\\\\s|$)").replace("|lheading", "")
      .replace("|table", "").replace("blockquote", " {0,3}>").replace(
        "fences",
        " {0,3}(?:\`{3,}(?=[^\`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n",
      ).replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace(
        "html",
        "</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)",
      ).replace("tag", R).getRegex(),
    I = {
      blockquote: p(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/).replace("paragraph", S).getRegex(),
      code: /^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/,
      def: z,
      fences:
        /^ {0,3}(\`{3,}(?=[^\`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~\`]* *(?=\\n|$)|$)/,
      heading: /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/,
      hr: b,
      html: A,
      lheading: m,
      list: T,
      newline: /^(?:[ \\t]*(?:\\n|$))+/,
      paragraph: S,
      table: k,
      text: /^[^\\n]+/,
    },
    E = p(
      "^ *([^\\\\n ].*)\\\\n {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)",
    ).replace("hr", b).replace("heading", " {0,3}#{1,6}(?:\\\\s|$)").replace("blockquote", " {0,3}>")
      .replace("code", "(?: {4}| {0,3}\\t)[^\\\\n]").replace(
        "fences",
        " {0,3}(?:\`{3,}(?=[^\`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n",
      ).replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace(
        "html",
        "</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)",
      ).replace("tag", R).getRegex(),
    q = {
      ...I,
      table: E,
      paragraph: p(y).replace("hr", b).replace("heading", " {0,3}#{1,6}(?:\\\\s|$)").replace(
        "|lheading",
        "",
      ).replace("table", E).replace("blockquote", " {0,3}>").replace(
        "fences",
        " {0,3}(?:\`{3,}(?=[^\`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n",
      ).replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace(
        "html",
        "</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)",
      ).replace("tag", R).getRegex(),
    },
    Z = {
      ...I,
      html: p(
        "^ *(?:comment *(?:\\\\n|\\\\s*$)|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)|<tag(?:\\"[^\\"]*\\"|'[^']*'|\\\\s[^'\\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))",
      ).replace("comment", _).replace(
        /tag/g,
        "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b",
      ).getRegex(),
      def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +(["(][^\\n]+[")]))? *(?:\\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\\n+|$)/,
      fences: k,
      lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,
      paragraph: p(y).replace("hr", b).replace("heading", " *#{1,6} *[^\\n]").replace("lheading", m)
        .replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace(
          "|list",
          "",
        ).replace("|html", "").replace("|tag", "").getRegex(),
    },
    P = /^\\\\([!"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_\`{|}~])/,
    L = /^( {2,}|\\\\)\\n(?!\\s*$)/,
    v = "\\\\p{P}\\\\p{S}",
    Q = p(/^((?![*_])[\\spunctuation])/, "u").replace(/punctuation/g, v).getRegex(),
    B = p(/^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/, "u").replace(
      /punct/g,
      v,
    ).getRegex(),
    M = p(
      "^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\\\*)[punct](\\\\*+)(?=[\\\\s]|$)|[^punct\\\\s](\\\\*+)(?!\\\\*)(?=[punct\\\\s]|$)|(?!\\\\*)[punct\\\\s](\\\\*+)(?=[^punct\\\\s])|[\\\\s](\\\\*+)(?!\\\\*)(?=[punct])|(?!\\\\*)[punct](\\\\*+)(?!\\\\*)(?=[punct])|[^punct\\\\s](\\\\*+)(?=[^punct\\\\s])",
      "gu",
    ).replace(/punct/g, v).getRegex(),
    O = p(
      "^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\\\s]|$)|[^punct\\\\s](_+)(?!_)(?=[punct\\\\s]|$)|(?!_)[punct\\\\s](_+)(?=[^punct\\\\s])|[\\\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])",
      "gu",
    ).replace(/punct/g, v).getRegex(),
    j = p(/\\\\([punct])/, "gu").replace(/punct/g, v).getRegex(),
    D = p(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)
      .replace(
        "email",
        /[a-zA-Z0-9.!#$%&'*+/=?^_\`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/,
      ).getRegex(),
    C = p(_).replace("(?:--\\x3e|$)", "--\\x3e").getRegex(),
    H = p(
      "^comment|^</[a-zA-Z][\\\\w:-]*\\\\s*>|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>|^<\\\\?[\\\\s\\\\S]*?\\\\?>|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>",
    ).replace("comment", C).replace(
      "attribute",
      /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*"[^"]*"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s"'=<>\`]+)?/,
    ).getRegex(),
    U = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|\`[^\`]*\`|[^\\[\\]\\\\\`])*?/,
    X = p(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/).replace("label", U).replace(
      "href",
      /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/,
    ).replace("title", /"(?:\\\\"?|[^"\\\\])*"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/).getRegex(),
    F = p(/^!?\\[(label)\\]\\[(ref)\\]/).replace("label", U).replace("ref", $).getRegex(),
    N = p(/^!?\\[(ref)\\](?:\\[\\])?/).replace("ref", $).getRegex(),
    G = {
      _backpedal: k,
      anyPunctuation: j,
      autolink: D,
      blockSkip: /\\[[^[\\]]*?\\]\\((?:\\\\.|[^\\\\\\(\\)]|\\((?:\\\\.|[^\\\\\\(\\)])*\\))*\\)|\`[^\`]*?\`|<[^<>]*?>/g,
      br: L,
      code: /^(\`+)([^\`]|[^\`][\\s\\S]*?[^\`])\\1(?!\`)/,
      del: k,
      emStrongLDelim: B,
      emStrongRDelimAst: M,
      emStrongRDelimUnd: O,
      escape: P,
      link: X,
      nolink: N,
      punctuation: Q,
      reflink: F,
      reflinkSearch: p("reflink|nolink(?!\\\\()", "g").replace("reflink", F).replace("nolink", N)
        .getRegex(),
      tag: H,
      text: /^(\`+|[^\`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[\`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/,
      url: k,
    },
    J = {
      ...G,
      link: p(/^!?\\[(label)\\]\\((.*?)\\)/).replace("label", U).getRegex(),
      reflink: p(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace("label", U).getRegex(),
    },
    K = {
      ...G,
      escape: p(P).replace("])", "~|])").getRegex(),
      url: p(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, "i").replace(
        "email",
        /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      ).getRegex(),
      _backpedal: /(?:[^?!.,:;*_'"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
      del: /^(~~?)(?=[^\\s~])((?:\\\\.|[^\\\\])*?(?:\\\\.|[^\\s~\\\\]))\\1(?=[^~]|$)/,
      text:
        /^([\`~]+|[^\`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_\`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[\`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_\`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_\`{\\|}~-]+@)))/,
    },
    V = {
      ...K,
      br: p(L).replace("{2,}", "*").getRegex(),
      text: p(K.text).replace("\\\\b_", "\\\\b_| {2,}\\\\n").replace(/\\{2,\\}/g, "*").getRegex(),
    },
    W = { normal: I, gfm: q, pedantic: Z },
    Y = { normal: G, gfm: K, breaks: V, pedantic: J };
  class ee {
    tokens;
    options;
    state;
    tokenizer;
    inlineQueue;
    constructor(t) {
      this.tokens = [],
        this.tokens.links = Object.create(null),
        this.options = t || e.defaults,
        this.options.tokenizer = this.options.tokenizer || new x(),
        this.tokenizer = this.options.tokenizer,
        this.tokenizer.options = this.options,
        this.tokenizer.lexer = this,
        this.inlineQueue = [],
        this.state = { inLink: !1, inRawBlock: !1, top: !0 };
      const n = { block: W.normal, inline: Y.normal };
      this.options.pedantic ? (n.block = W.pedantic, n.inline = Y.pedantic) : this.options.gfm &&
        (n.block = W.gfm, this.options.breaks ? n.inline = Y.breaks : n.inline = Y.gfm),
        this.tokenizer.rules = n;
    }
    static get rules() {
      return { block: W, inline: Y };
    }
    static lex(e, t) {
      return new ee(t).lex(e);
    }
    static lexInline(e, t) {
      return new ee(t).inlineTokens(e);
    }
    lex(e) {
      e = e.replace(/\\r\\n|\\r/g, "\\n"), this.blockTokens(e, this.tokens);
      for (let e = 0; e < this.inlineQueue.length; e++) {
        const t = this.inlineQueue[e];
        this.inlineTokens(t.src, t.tokens);
      }
      return this.inlineQueue = [], this.tokens;
    }
    blockTokens(e, t = [], n = !1) {
      let s, r, i;
      for (this.options.pedantic && (e = e.replace(/\\t/g, "    ").replace(/^ +$/gm, "")); e;) {
        if (
          !(this.options.extensions && this.options.extensions.block &&
            this.options.extensions.block.some((n) =>
              !!(s = n.call({ lexer: this }, e, t)) &&
              (e = e.substring(s.raw.length), t.push(s), !0)
            ))
        ) {
          if (s = this.tokenizer.space(e)) {
            e = e.substring(s.raw.length),
              1 === s.raw.length && t.length > 0 ? t[t.length - 1].raw += "\\n" : t.push(s);
          } else if (s = this.tokenizer.code(e)) {
            e = e.substring(s.raw.length),
              r = t[t.length - 1],
              !r || "paragraph" !== r.type && "text" !== r.type
                ? t.push(s)
                : (r.raw += "\\n" + s.raw,
                  r.text += "\\n" + s.text,
                  this.inlineQueue[this.inlineQueue.length - 1].src = r.text);
          } else if (s = this.tokenizer.fences(e)) e = e.substring(s.raw.length), t.push(s);
          else if (s = this.tokenizer.heading(e)) e = e.substring(s.raw.length), t.push(s);
          else if (s = this.tokenizer.hr(e)) e = e.substring(s.raw.length), t.push(s);
          else if (s = this.tokenizer.blockquote(e)) e = e.substring(s.raw.length), t.push(s);
          else if (s = this.tokenizer.list(e)) e = e.substring(s.raw.length), t.push(s);
          else if (s = this.tokenizer.html(e)) e = e.substring(s.raw.length), t.push(s);
          else if (s = this.tokenizer.def(e)) {
            e = e.substring(s.raw.length),
              r = t[t.length - 1],
              !r || "paragraph" !== r.type && "text" !== r.type
                ? this.tokens.links[s.tag] ||
                  (this.tokens.links[s.tag] = { href: s.href, title: s.title })
                : (r.raw += "\\n" + s.raw,
                  r.text += "\\n" + s.raw,
                  this.inlineQueue[this.inlineQueue.length - 1].src = r.text);
          } else if (s = this.tokenizer.table(e)) e = e.substring(s.raw.length), t.push(s);
          else if (s = this.tokenizer.lheading(e)) e = e.substring(s.raw.length), t.push(s);
          else {
            if (i = e, this.options.extensions && this.options.extensions.startBlock) {
              let t = 1 / 0;
              const n = e.slice(1);
              let s;
              this.options.extensions.startBlock.forEach((e) => {
                s = e.call({ lexer: this }, n),
                  "number" == typeof s && s >= 0 && (t = Math.min(t, s));
              }), t < 1 / 0 && t >= 0 && (i = e.substring(0, t + 1));
            }
            if (this.state.top && (s = this.tokenizer.paragraph(i))) {
              r = t[t.length - 1],
                n && "paragraph" === r?.type
                  ? (r.raw += "\\n" + s.raw,
                    r.text += "\\n" + s.text,
                    this.inlineQueue.pop(),
                    this.inlineQueue[this.inlineQueue.length - 1].src = r.text)
                  : t.push(s),
                n = i.length !== e.length,
                e = e.substring(s.raw.length);
            } else if (s = this.tokenizer.text(e)) {
              e = e.substring(s.raw.length),
                r = t[t.length - 1],
                r && "text" === r.type
                  ? (r.raw += "\\n" + s.raw,
                    r.text += "\\n" + s.text,
                    this.inlineQueue.pop(),
                    this.inlineQueue[this.inlineQueue.length - 1].src = r.text)
                  : t.push(s);
            } else if (e) {
              const t = "Infinite loop on byte: " + e.charCodeAt(0);
              if (this.options.silent) {
                console.error(t);
                break;
              }
              throw new Error(t);
            }
          }
        }
      }
      return this.state.top = !0, t;
    }
    inline(e, t = []) {
      return this.inlineQueue.push({ src: e, tokens: t }), t;
    }
    inlineTokens(e, t = []) {
      let n, s, r, i, l, o, a = e;
      if (this.tokens.links) {
        const e = Object.keys(this.tokens.links);
        if (e.length > 0) {
          for (; null != (i = this.tokenizer.rules.inline.reflinkSearch.exec(a));) {
            e.includes(i[0].slice(i[0].lastIndexOf("[") + 1, -1)) &&
              (a = a.slice(0, i.index) + "[" + "a".repeat(i[0].length - 2) + "]" +
                a.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
          }
        }
      }
      for (; null != (i = this.tokenizer.rules.inline.blockSkip.exec(a));) {
        a = a.slice(0, i.index) + "[" + "a".repeat(i[0].length - 2) + "]" +
          a.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      }
      for (; null != (i = this.tokenizer.rules.inline.anyPunctuation.exec(a));) {
        a = a.slice(0, i.index) + "++" +
          a.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
      }
      for (; e;) {
        if (
          l || (o = ""),
            l = !1,
            !(this.options.extensions && this.options.extensions.inline &&
              this.options.extensions.inline.some((s) =>
                !!(n = s.call({ lexer: this }, e, t)) &&
                (e = e.substring(n.raw.length), t.push(n), !0)
              ))
        ) {
          if (n = this.tokenizer.escape(e)) e = e.substring(n.raw.length), t.push(n);
          else if (n = this.tokenizer.tag(e)) {
            e = e.substring(n.raw.length),
              s = t[t.length - 1],
              s && "text" === n.type && "text" === s.type
                ? (s.raw += n.raw, s.text += n.text)
                : t.push(n);
          } else if (n = this.tokenizer.link(e)) e = e.substring(n.raw.length), t.push(n);
          else if (n = this.tokenizer.reflink(e, this.tokens.links)) {
            e = e.substring(n.raw.length),
              s = t[t.length - 1],
              s && "text" === n.type && "text" === s.type
                ? (s.raw += n.raw, s.text += n.text)
                : t.push(n);
          } else if (n = this.tokenizer.emStrong(e, a, o)) e = e.substring(n.raw.length), t.push(n);
          else if (n = this.tokenizer.codespan(e)) e = e.substring(n.raw.length), t.push(n);
          else if (n = this.tokenizer.br(e)) e = e.substring(n.raw.length), t.push(n);
          else if (n = this.tokenizer.del(e)) e = e.substring(n.raw.length), t.push(n);
          else if (n = this.tokenizer.autolink(e)) e = e.substring(n.raw.length), t.push(n);
          else if (this.state.inLink || !(n = this.tokenizer.url(e))) {
            if (r = e, this.options.extensions && this.options.extensions.startInline) {
              let t = 1 / 0;
              const n = e.slice(1);
              let s;
              this.options.extensions.startInline.forEach((e) => {
                s = e.call({ lexer: this }, n),
                  "number" == typeof s && s >= 0 && (t = Math.min(t, s));
              }), t < 1 / 0 && t >= 0 && (r = e.substring(0, t + 1));
            }
            if (n = this.tokenizer.inlineText(r)) {
              e = e.substring(n.raw.length),
                "_" !== n.raw.slice(-1) && (o = n.raw.slice(-1)),
                l = !0,
                s = t[t.length - 1],
                s && "text" === s.type ? (s.raw += n.raw, s.text += n.text) : t.push(n);
            } else if (e) {
              const t = "Infinite loop on byte: " + e.charCodeAt(0);
              if (this.options.silent) {
                console.error(t);
                break;
              }
              throw new Error(t);
            }
          } else e = e.substring(n.raw.length), t.push(n);
        }
      }
      return t;
    }
  }
  class te {
    options;
    parser;
    constructor(t) {
      this.options = t || e.defaults;
    }
    space(e) {
      return "";
    }
    code({ text: e, lang: t, escaped: n }) {
      const s = (t || "").match(/^\\S*/)?.[0], r = e.replace(/\\n$/, "") + "\\n";
      return s
        ? '<pre><code class="language-' + c(s) + '">' + (n ? r : c(r, !0)) + "</code></pre>\\n"
        : "<pre><code>" + (n ? r : c(r, !0)) + "</code></pre>\\n";
    }
    blockquote({ tokens: e }) {
      return \`<blockquote>\\n\${this.parser.parse(e)}</blockquote>\\n\`;
    }
    html({ text: e }) {
      return e;
    }
    heading({ tokens: e, depth: t }) {
      return \`<h\${t}>\${this.parser.parseInline(e)}</h\${t}>\\n\`;
    }
    hr(e) {
      return "<hr>\\n";
    }
    list(e) {
      const t = e.ordered, n = e.start;
      let s = "";
      for (let t = 0; t < e.items.length; t++) {
        const n = e.items[t];
        s += this.listitem(n);
      }
      const r = t ? "ol" : "ul";
      return "<" + r + (t && 1 !== n ? ' start="' + n + '"' : "") + ">\\n" + s + "</" + r + ">\\n";
    }
    listitem(e) {
      let t = "";
      if (e.task) {
        const n = this.checkbox({ checked: !!e.checked });
        e.loose
          ? e.tokens.length > 0 && "paragraph" === e.tokens[0].type
            ? (e.tokens[0].text = n + " " + e.tokens[0].text,
              e.tokens[0].tokens && e.tokens[0].tokens.length > 0 &&
              "text" === e.tokens[0].tokens[0].type &&
              (e.tokens[0].tokens[0].text = n + " " + e.tokens[0].tokens[0].text))
            : e.tokens.unshift({ type: "text", raw: n + " ", text: n + " " })
          : t += n + " ";
      }
      return t += this.parser.parse(e.tokens, !!e.loose), \`<li>\${t}</li>\\n\`;
    }
    checkbox({ checked: e }) {
      return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
    }
    paragraph({ tokens: e }) {
      return \`<p>\${this.parser.parseInline(e)}</p>\\n\`;
    }
    table(e) {
      let t = "", n = "";
      for (let t = 0; t < e.header.length; t++) n += this.tablecell(e.header[t]);
      t += this.tablerow({ text: n });
      let s = "";
      for (let t = 0; t < e.rows.length; t++) {
        const r = e.rows[t];
        n = "";
        for (let e = 0; e < r.length; e++) n += this.tablecell(r[e]);
        s += this.tablerow({ text: n });
      }
      return s && (s = \`<tbody>\${s}</tbody>\`),
        "<table>\\n<thead>\\n" + t + "</thead>\\n" + s + "</table>\\n";
    }
    tablerow({ text: e }) {
      return \`<tr>\\n\${e}</tr>\\n\`;
    }
    tablecell(e) {
      const t = this.parser.parseInline(e.tokens), n = e.header ? "th" : "td";
      return (e.align ? \`<\${n} align="\${e.align}">\` : \`<\${n}>\`) + t + \`</\${n}>\\n\`;
    }
    strong({ tokens: e }) {
      return \`<strong>\${this.parser.parseInline(e)}</strong>\`;
    }
    em({ tokens: e }) {
      return \`<em>\${this.parser.parseInline(e)}</em>\`;
    }
    codespan({ text: e }) {
      return \`<code>\${e}</code>\`;
    }
    br(e) {
      return "<br>";
    }
    del({ tokens: e }) {
      return \`<del>\${this.parser.parseInline(e)}</del>\`;
    }
    link({ href: e, title: t, tokens: n }) {
      const s = this.parser.parseInline(n), r = u(e);
      if (null === r) return s;
      let i = '<a href="' + (e = r) + '"';
      return t && (i += ' title="' + t + '"'), i += ">" + s + "</a>", i;
    }
    image({ href: e, title: t, text: n }) {
      const s = u(e);
      if (null === s) return n;
      let r = \`<img src="\${e = s}" alt="\${n}"\`;
      return t && (r += \` title="\${t}"\`), r += ">", r;
    }
    text(e) {
      return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : e.text;
    }
  }
  class ne {
    strong({ text: e }) {
      return e;
    }
    em({ text: e }) {
      return e;
    }
    codespan({ text: e }) {
      return e;
    }
    del({ text: e }) {
      return e;
    }
    html({ text: e }) {
      return e;
    }
    text({ text: e }) {
      return e;
    }
    link({ text: e }) {
      return "" + e;
    }
    image({ text: e }) {
      return "" + e;
    }
    br() {
      return "";
    }
  }
  class se {
    options;
    renderer;
    textRenderer;
    constructor(t) {
      this.options = t || e.defaults,
        this.options.renderer = this.options.renderer || new te(),
        this.renderer = this.options.renderer,
        this.renderer.options = this.options,
        this.renderer.parser = this,
        this.textRenderer = new ne();
    }
    static parse(e, t) {
      return new se(t).parse(e);
    }
    static parseInline(e, t) {
      return new se(t).parseInline(e);
    }
    parse(e, t = !0) {
      let n = "";
      for (let s = 0; s < e.length; s++) {
        const r = e[s];
        if (
          this.options.extensions && this.options.extensions.renderers &&
          this.options.extensions.renderers[r.type]
        ) {
          const e = r, t = this.options.extensions.renderers[e.type].call({ parser: this }, e);
          if (
            !1 !== t ||
            ![
              "space",
              "hr",
              "heading",
              "code",
              "table",
              "blockquote",
              "list",
              "html",
              "paragraph",
              "text",
            ].includes(e.type)
          ) {
            n += t || "";
            continue;
          }
        }
        const i = r;
        switch (i.type) {
          case "space":
            n += this.renderer.space(i);
            continue;
          case "hr":
            n += this.renderer.hr(i);
            continue;
          case "heading":
            n += this.renderer.heading(i);
            continue;
          case "code":
            n += this.renderer.code(i);
            continue;
          case "table":
            n += this.renderer.table(i);
            continue;
          case "blockquote":
            n += this.renderer.blockquote(i);
            continue;
          case "list":
            n += this.renderer.list(i);
            continue;
          case "html":
            n += this.renderer.html(i);
            continue;
          case "paragraph":
            n += this.renderer.paragraph(i);
            continue;
          case "text": {
            let r = i, l = this.renderer.text(r);
            for (; s + 1 < e.length && "text" === e[s + 1].type;) {
              r = e[++s], l += "\\n" + this.renderer.text(r);
            }
            n += t
              ? this.renderer.paragraph({
                type: "paragraph",
                raw: l,
                text: l,
                tokens: [{ type: "text", raw: l, text: l }],
              })
              : l;
            continue;
          }
          default: {
            const e = 'Token with "' + i.type + '" type was not found.';
            if (this.options.silent) return console.error(e), "";
            throw new Error(e);
          }
        }
      }
      return n;
    }
    parseInline(e, t) {
      t = t || this.renderer;
      let n = "";
      for (let s = 0; s < e.length; s++) {
        const r = e[s];
        if (
          this.options.extensions && this.options.extensions.renderers &&
          this.options.extensions.renderers[r.type]
        ) {
          const e = this.options.extensions.renderers[r.type].call({ parser: this }, r);
          if (
            !1 !== e ||
            !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"]
              .includes(r.type)
          ) {
            n += e || "";
            continue;
          }
        }
        const i = r;
        switch (i.type) {
          case "escape":
          case "text":
            n += t.text(i);
            break;
          case "html":
            n += t.html(i);
            break;
          case "link":
            n += t.link(i);
            break;
          case "image":
            n += t.image(i);
            break;
          case "strong":
            n += t.strong(i);
            break;
          case "em":
            n += t.em(i);
            break;
          case "codespan":
            n += t.codespan(i);
            break;
          case "br":
            n += t.br(i);
            break;
          case "del":
            n += t.del(i);
            break;
          default: {
            const e = 'Token with "' + i.type + '" type was not found.';
            if (this.options.silent) return console.error(e), "";
            throw new Error(e);
          }
        }
      }
      return n;
    }
  }
  class re {
    options;
    block;
    constructor(t) {
      this.options = t || e.defaults;
    }
    static passThroughHooks = new Set(["preprocess", "postprocess", "processAllTokens"]);
    preprocess(e) {
      return e;
    }
    postprocess(e) {
      return e;
    }
    processAllTokens(e) {
      return e;
    }
    provideLexer() {
      return this.block ? ee.lex : ee.lexInline;
    }
    provideParser() {
      return this.block ? se.parse : se.parseInline;
    }
  }
  class ie {
    defaults = {
      async: !1,
      breaks: !1,
      extensions: null,
      gfm: !0,
      hooks: null,
      pedantic: !1,
      renderer: null,
      silent: !1,
      tokenizer: null,
      walkTokens: null,
    };
    options = this.setOptions;
    parse = this.parseMarkdown(!0);
    parseInline = this.parseMarkdown(!1);
    Parser = se;
    Renderer = te;
    TextRenderer = ne;
    Lexer = ee;
    Tokenizer = x;
    Hooks = re;
    constructor(...e) {
      this.use(...e);
    }
    walkTokens(e, t) {
      let n = [];
      for (const s of e) {
        switch (n = n.concat(t.call(this, s)), s.type) {
          case "table": {
            const e = s;
            for (const s of e.header) n = n.concat(this.walkTokens(s.tokens, t));
            for (const s of e.rows) for (const e of s) n = n.concat(this.walkTokens(e.tokens, t));
            break;
          }
          case "list": {
            const e = s;
            n = n.concat(this.walkTokens(e.items, t));
            break;
          }
          default: {
            const e = s;
            this.defaults.extensions?.childTokens?.[e.type]
              ? this.defaults.extensions.childTokens[e.type].forEach((s) => {
                const r = e[s].flat(1 / 0);
                n = n.concat(this.walkTokens(r, t));
              })
              : e.tokens && (n = n.concat(this.walkTokens(e.tokens, t)));
          }
        }
      }
      return n;
    }
    use(...e) {
      const t = this.defaults.extensions || { renderers: {}, childTokens: {} };
      return e.forEach((e) => {
        const n = { ...e };
        if (
          n.async = this.defaults.async || n.async || !1,
            e.extensions && (e.extensions.forEach((e) => {
              if (!e.name) throw new Error("extension name required");
              if ("renderer" in e) {
                const n = t.renderers[e.name];
                t.renderers[e.name] = n
                  ? function (...t) {
                    let s = e.renderer.apply(this, t);
                    return !1 === s && (s = n.apply(this, t)), s;
                  }
                  : e.renderer;
              }
              if ("tokenizer" in e) {
                if (!e.level || "block" !== e.level && "inline" !== e.level) {
                  throw new Error("extension level must be 'block' or 'inline'");
                }
                const n = t[e.level];
                n ? n.unshift(e.tokenizer) : t[e.level] = [e.tokenizer],
                  e.start &&
                  ("block" === e.level
                    ? t.startBlock ? t.startBlock.push(e.start) : t.startBlock = [e.start]
                    : "inline" === e.level &&
                      (t.startInline ? t.startInline.push(e.start) : t.startInline = [e.start]));
              }
              "childTokens" in e && e.childTokens && (t.childTokens[e.name] = e.childTokens);
            }),
              n.extensions = t),
            e.renderer
        ) {
          const t = this.defaults.renderer || new te(this.defaults);
          for (const n in e.renderer) {
            if (!(n in t)) throw new Error(\`renderer '\${n}' does not exist\`);
            if (["options", "parser"].includes(n)) continue;
            const s = n, r = e.renderer[s], i = t[s];
            t[s] = (...e) => {
              let n = r.apply(t, e);
              return !1 === n && (n = i.apply(t, e)), n || "";
            };
          }
          n.renderer = t;
        }
        if (e.tokenizer) {
          const t = this.defaults.tokenizer || new x(this.defaults);
          for (const n in e.tokenizer) {
            if (!(n in t)) throw new Error(\`tokenizer '\${n}' does not exist\`);
            if (["options", "rules", "lexer"].includes(n)) continue;
            const s = n, r = e.tokenizer[s], i = t[s];
            t[s] = (...e) => {
              let n = r.apply(t, e);
              return !1 === n && (n = i.apply(t, e)), n;
            };
          }
          n.tokenizer = t;
        }
        if (e.hooks) {
          const t = this.defaults.hooks || new re();
          for (const n in e.hooks) {
            if (!(n in t)) throw new Error(\`hook '\${n}' does not exist\`);
            if (["options", "block"].includes(n)) continue;
            const s = n, r = e.hooks[s], i = t[s];
            re.passThroughHooks.has(n)
              ? t[s] = (e) => {
                if (this.defaults.async) {
                  return Promise.resolve(r.call(t, e)).then((e) => i.call(t, e));
                }
                const n = r.call(t, e);
                return i.call(t, n);
              }
              : t[s] = (...e) => {
                let n = r.apply(t, e);
                return !1 === n && (n = i.apply(t, e)), n;
              };
          }
          n.hooks = t;
        }
        if (e.walkTokens) {
          const t = this.defaults.walkTokens, s = e.walkTokens;
          n.walkTokens = function (e) {
            let n = [];
            return n.push(s.call(this, e)), t && (n = n.concat(t.call(this, e))), n;
          };
        }
        this.defaults = { ...this.defaults, ...n };
      }),
        this;
    }
    setOptions(e) {
      return this.defaults = { ...this.defaults, ...e }, this;
    }
    lexer(e, t) {
      return ee.lex(e, t ?? this.defaults);
    }
    parser(e, t) {
      return se.parse(e, t ?? this.defaults);
    }
    parseMarkdown(e) {
      return (t, n) => {
        const s = { ...n }, r = { ...this.defaults, ...s }, i = this.onError(!!r.silent, !!r.async);
        if (!0 === this.defaults.async && !1 === s.async) {
          return i(
            new Error(
              "marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.",
            ),
          );
        }
        if (null == t) return i(new Error("marked(): input parameter is undefined or null"));
        if ("string" != typeof t) {
          return i(
            new Error(
              "marked(): input parameter is of type " + Object.prototype.toString.call(t) +
                ", string expected",
            ),
          );
        }
        r.hooks && (r.hooks.options = r, r.hooks.block = e);
        const l = r.hooks ? r.hooks.provideLexer() : e ? ee.lex : ee.lexInline,
          o = r.hooks ? r.hooks.provideParser() : e ? se.parse : se.parseInline;
        if (r.async) {
          return Promise.resolve(r.hooks ? r.hooks.preprocess(t) : t).then((e) => l(e, r)).then(
            (e) => r.hooks ? r.hooks.processAllTokens(e) : e,
          ).then(
            (e) => r.walkTokens ? Promise.all(this.walkTokens(e, r.walkTokens)).then(() => e) : e,
          ).then((e) => o(e, r)).then((e) => r.hooks ? r.hooks.postprocess(e) : e).catch(i);
        }
        try {
          r.hooks && (t = r.hooks.preprocess(t));
          let e = l(t, r);
          r.hooks && (e = r.hooks.processAllTokens(e)),
            r.walkTokens && this.walkTokens(e, r.walkTokens);
          let n = o(e, r);
          return r.hooks && (n = r.hooks.postprocess(n)), n;
        } catch (e) {
          return i(e);
        }
      };
    }
    onError(e, t) {
      return (n) => {
        if (n.message += "\\nPlease report this to https://github.com/markedjs/marked.", e) {
          const e = "<p>An error occurred:</p><pre>" + c(n.message + "", !0) + "</pre>";
          return t ? Promise.resolve(e) : e;
        }
        if (t) return Promise.reject(n);
        throw n;
      };
    }
  }
  const le = new ie();
  function oe(e, t) {
    return le.parse(e, t);
  }
  oe.options = oe.setOptions = function (e) {
    return le.setOptions(e), oe.defaults = le.defaults, n(oe.defaults), oe;
  },
    oe.getDefaults = t,
    oe.defaults = e.defaults,
    oe.use = function (...e) {
      return le.use(...e), oe.defaults = le.defaults, n(oe.defaults), oe;
    },
    oe.walkTokens = function (e, t) {
      return le.walkTokens(e, t);
    },
    oe.parseInline = le.parseInline,
    oe.Parser = se,
    oe.parser = se.parse,
    oe.Renderer = te,
    oe.TextRenderer = ne,
    oe.Lexer = ee,
    oe.lexer = ee.lex,
    oe.Tokenizer = x,
    oe.Hooks = re,
    oe.parse = oe;
  const ae = oe.options,
    ce = oe.setOptions,
    he = oe.use,
    pe = oe.walkTokens,
    ue = oe.parseInline,
    ke = oe,
    ge = se.parse,
    fe = ee.lex;
  e.Hooks = re,
    e.Lexer = ee,
    e.Marked = ie,
    e.Parser = se,
    e.Renderer = te,
    e.TextRenderer = ne,
    e.Tokenizer = x,
    e.getDefaults = t,
    e.lexer = fe,
    e.marked = oe,
    e.options = ae,
    e.parse = ke,
    e.parseInline = ue,
    e.parser = ge,
    e.setOptions = ce,
    e.use = he,
    e.walkTokens = pe;
});
`,
    isBinary: false,
  },
  "prism-go.min.js": {
    content: `Prism.languages.go = Prism.languages.extend("clike", {
  string: { pattern: /(^|[^\\\\])"(?:\\\\.|[^"\\\\\\r\\n])*"|\`[^\`]*\`/, lookbehind: !0, greedy: !0 },
  keyword:
    /\\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\\b/,
  boolean: /\\b(?:_|false|iota|nil|true)\\b/,
  number: [
    /\\b0(?:b[01_]+|o[0-7_]+)i?\\b/i,
    /\\b0x(?:[a-f\\d_]+(?:\\.[a-f\\d_]*)?|\\.[a-f\\d_]+)(?:p[+-]?\\d+(?:_\\d+)*)?i?(?!\\w)/i,
    /(?:\\b\\d[\\d_]*(?:\\.[\\d_]*)?|\\B\\.\\d[\\d_]*)(?:e[+-]?[\\d_]+)?i?(?!\\w)/i,
  ],
  operator: /[*\\/%^!=]=?|\\+[=+]?|-[=-]?|\\|[=|]?|&(?:=|&|\\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\\.\\.\\./,
  builtin:
    /\\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\\b/,
}),
  Prism.languages.insertBefore("go", "string", {
    char: { pattern: /'(?:\\\\.|[^'\\\\\\r\\n]){0,10}'/, greedy: !0 },
  }),
  delete Prism.languages.go["class-name"];
`,
    isBinary: false,
  },
  "prism-bash.min.js": {
    content: `!function (e) {
  var t =
      "\\\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\\\b",
    a = {
      pattern: /(^(["']?)\\w+\\2)[ \\t]+\\S.*/,
      lookbehind: !0,
      alias: "punctuation",
      inside: null,
    },
    n = {
      bash: a,
      environment: { pattern: RegExp("\\\\$" + t), alias: "constant" },
      variable: [{
        pattern: /\\$?\\(\\([\\s\\S]+?\\)\\)/,
        greedy: !0,
        inside: {
          variable: [{ pattern: /(^\\$\\(\\([\\s\\S]+)\\)\\)/, lookbehind: !0 }, /^\\$\\(\\(/],
          number: /\\b0x[\\dA-Fa-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[Ee]-?\\d+)?/,
          operator: /--|\\+\\+|\\*\\*=?|<<=?|>>=?|&&|\\|\\||[=!+\\-*/%<>^&|]=?|[?~:]/,
          punctuation: /\\(\\(?|\\)\\)?|,|;/,
        },
      }, {
        pattern: /\\$\\((?:\\([^)]+\\)|[^()])+\\)|\`[^\`]+\`/,
        greedy: !0,
        inside: { variable: /^\\$\\(|^\`|\\)$|\`$/ },
      }, {
        pattern: /\\$\\{[^}]+\\}/,
        greedy: !0,
        inside: {
          operator: /:[-=?+]?|[!\\/]|##?|%%?|\\^\\^?|,,?/,
          punctuation: /[\\[\\]]/,
          environment: { pattern: RegExp("(\\\\{)" + t), lookbehind: !0, alias: "constant" },
        },
      }, /\\$(?:\\w+|[#?*!@$])/],
      entity:
        /\\\\(?:[abceEfnrtv\\\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/,
    };
  e.languages.bash = {
    shebang: { pattern: /^#!\\s*\\/.*/, alias: "important" },
    comment: { pattern: /(^|[^"{\\\\$])#.*/, lookbehind: !0 },
    "function-name": [{
      pattern: /(\\bfunction\\s+)[\\w-]+(?=(?:\\s*\\(?:\\s*\\))?\\s*\\{)/,
      lookbehind: !0,
      alias: "function",
    }, { pattern: /\\b[\\w-]+(?=\\s*\\(\\s*\\)\\s*\\{)/, alias: "function" }],
    "for-or-select": {
      pattern: /(\\b(?:for|select)\\s+)\\w+(?=\\s+in\\s)/,
      alias: "variable",
      lookbehind: !0,
    },
    "assign-left": {
      pattern: /(^|[\\s;|&]|[<>]\\()\\w+(?:\\.\\w+)*(?=\\+?=)/,
      inside: {
        environment: {
          pattern: RegExp("(^|[\\\\s;|&]|[<>]\\\\()" + t),
          lookbehind: !0,
          alias: "constant",
        },
      },
      alias: "variable",
      lookbehind: !0,
    },
    parameter: {
      pattern: /(^|\\s)-{1,2}(?:\\w+:[+-]?)?\\w+(?:\\.\\w+)*(?=[=\\s]|$)/,
      alias: "variable",
      lookbehind: !0,
    },
    string: [
      {
        pattern: /((?:^|[^<])<<-?\\s*)(\\w+)\\s[\\s\\S]*?(?:\\r?\\n|\\r)\\2/,
        lookbehind: !0,
        greedy: !0,
        inside: n,
      },
      {
        pattern: /((?:^|[^<])<<-?\\s*)(["'])(\\w+)\\2\\s[\\s\\S]*?(?:\\r?\\n|\\r)\\3/,
        lookbehind: !0,
        greedy: !0,
        inside: { bash: a },
      },
      {
        pattern: /(^|[^\\\\](?:\\\\\\\\)*)"(?:\\\\[\\s\\S]|\\$\\([^)]+\\)|\\$(?!\\()|\`[^\`]+\`|[^"\\\\\`$])*"/,
        lookbehind: !0,
        greedy: !0,
        inside: n,
      },
      { pattern: /(^|[^$\\\\])'[^']*'/, lookbehind: !0, greedy: !0 },
      { pattern: /\\$'(?:[^'\\\\]|\\\\[\\s\\S])*'/, greedy: !0, inside: { entity: n.entity } },
    ],
    environment: { pattern: RegExp("\\\\$?" + t), alias: "constant" },
    variable: n.variable,
    function: {
      pattern:
        /(^|[\\s;|&]|[<>]\\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\\s;|&])/,
      lookbehind: !0,
    },
    keyword: {
      pattern:
        /(^|[\\s;|&]|[<>]\\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\\s;|&])/,
      lookbehind: !0,
    },
    builtin: {
      pattern:
        /(^|[\\s;|&]|[<>]\\()(?:\\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\\s;|&])/,
      lookbehind: !0,
      alias: "class-name",
    },
    boolean: { pattern: /(^|[\\s;|&]|[<>]\\()(?:false|true)(?=$|[)\\s;|&])/, lookbehind: !0 },
    "file-descriptor": { pattern: /\\B&\\d\\b/, alias: "important" },
    operator: {
      pattern: /\\d?<>|>\\||\\+=|=[=~]?|!=?|<<[<-]?|[&\\d]?>>|\\d[<>]&?|[<>][&=]?|&[>&]?|\\|[&|]?/,
      inside: { "file-descriptor": { pattern: /^\\d/, alias: "important" } },
    },
    punctuation: /\\$?\\(\\(?|\\)\\)?|\\.\\.|[{}[\\];\\\\]/,
    number: { pattern: /(^|\\s)(?:[1-9]\\d*|0)(?:[.,]\\d+)?\\b/, lookbehind: !0 },
  }, a.inside = e.languages.bash;
  for (
    var s = [
        "comment",
        "function-name",
        "for-or-select",
        "assign-left",
        "parameter",
        "string",
        "environment",
        "function",
        "keyword",
        "builtin",
        "boolean",
        "file-descriptor",
        "operator",
        "punctuation",
        "number",
      ],
      o = n.variable[1].inside,
      i = 0;
    i < s.length;
    i++
  ) o[s[i]] = e.languages.bash[s[i]];
  e.languages.sh = e.languages.bash, e.languages.shell = e.languages.bash;
}(Prism);
`,
    isBinary: false,
  },
  "prism-docker.min.js": {
    content: `!function (e) {
  var n = "(?:[ \\t]+(?![ \\t])(?:<SP_BS>)?|<SP_BS>)".replace(/<SP_BS>/g, function () {
      return "\\\\\\\\[\\r\\n](?:\\\\s|\\\\\\\\[\\r\\n]|#.*(?!.))*(?![\\\\s#]|\\\\\\\\[\\r\\n])";
    }),
    r = "\\"(?:[^\\"\\\\\\\\\\r\\n]|\\\\\\\\(?:\\r\\n|[^]))*\\"|'(?:[^'\\\\\\\\\\r\\n]|\\\\\\\\(?:\\r\\n|[^]))*'",
    t = "--[\\\\w-]+=(?:<STR>|(?![\\"'])(?:[^\\\\s\\\\\\\\]|\\\\\\\\.)+)".replace(/<STR>/g, function () {
      return r;
    }),
    o = { pattern: RegExp(r), greedy: !0 },
    i = { pattern: /(^[ \\t]*)#.*/m, lookbehind: !0, greedy: !0 };
  function a(e, r) {
    return e = e.replace(/<OPT>/g, function () {
      return t;
    }).replace(/<SP>/g, function () {
      return n;
    }),
      RegExp(e, r);
  }
  e.languages.docker = {
    instruction: {
      pattern:
        /(^[ \\t]*)(?:ADD|ARG|CMD|COPY|ENTRYPOINT|ENV|EXPOSE|FROM|HEALTHCHECK|LABEL|MAINTAINER|ONBUILD|RUN|SHELL|STOPSIGNAL|USER|VOLUME|WORKDIR)(?=\\s)(?:\\\\.|[^\\r\\n\\\\])*(?:\\\\$(?:\\s|#.*$)*(?![\\s#])(?:\\\\.|[^\\r\\n\\\\])*)*/im,
      lookbehind: !0,
      greedy: !0,
      inside: {
        options: {
          pattern: a("(^(?:ONBUILD<SP>)?\\\\w+<SP>)<OPT>(?:<SP><OPT>)*", "i"),
          lookbehind: !0,
          greedy: !0,
          inside: {
            property: { pattern: /(^|\\s)--[\\w-]+/, lookbehind: !0 },
            string: [o, { pattern: /(=)(?!["'])(?:[^\\s\\\\]|\\\\.)+/, lookbehind: !0 }],
            operator: /\\\\$/m,
            punctuation: /=/,
          },
        },
        keyword: [
          {
            pattern: a("(^(?:ONBUILD<SP>)?HEALTHCHECK<SP>(?:<OPT><SP>)*)(?:CMD|NONE)\\\\b", "i"),
            lookbehind: !0,
            greedy: !0,
          },
          {
            pattern: a("(^(?:ONBUILD<SP>)?FROM<SP>(?:<OPT><SP>)*(?!--)[^ \\t\\\\\\\\]+<SP>)AS", "i"),
            lookbehind: !0,
            greedy: !0,
          },
          { pattern: a("(^ONBUILD<SP>)\\\\w+", "i"), lookbehind: !0, greedy: !0 },
          { pattern: /^\\w+/, greedy: !0 },
        ],
        comment: i,
        string: o,
        variable: /\\$(?:\\w+|\\{[^{}"'\\\\]*\\})/,
        operator: /\\\\$/m,
      },
    },
    comment: i,
  }, e.languages.dockerfile = e.languages.docker;
}(Prism);
`,
    isBinary: false,
  }
};

/**
 * Gets an asset by its path
 */
export function getAsset(path: string): AssetInfo | undefined {
  // Normalize path (remove leading slash)
  const normalizedPath = path.startsWith("/") ? path.slice(1) : path;
  return assets[normalizedPath];
}

/**
 * Gets the content of an asset, handling binary/text differences
 */
export function getAssetContent(path: string): Uint8Array | string | undefined {
  const asset = getAsset(path);
  if (!asset) return undefined;

  if (asset.isBinary) {
    // Convert base64 back to binary
    const binaryString = atob(asset.content);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
  }

  return asset.content;
}

/**
 * Lists all available asset paths
 */
export function listAssets(): string[] {
  return Object.keys(assets);
}
